<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Benno111 Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/style.css">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="shortcut icon" href="/favicon.ico">
</head>
<body>

<div class="app-root">

  <div class="chat-root">

    <!-- LEFT SIDEBAR -->
    <aside class="chat-sidebar" id="chatSidebar">
      <button type="button" class="chat-sidebar-toggle" id="sidebarToggleBtn">
        Hide Sidebar
      </button>
      <div class="chat-sidebar-content">
        <button class="chat-side-btn" id="serverListBtn">DM List</button>
        <button class="chat-side-btn" id="channelListBtn">Channels</button>
        <button class="chat-side-btn chat-side-btn-small" id="friendsBtn">Friends</button>
        <button class="chat-side-btn chat-side-btn-small" id="friendsRequestsBtn">Requests</button>
        <button class="chat-side-btn chat-side-btn-small" id="onlineBtn">Online</button>
        <button class="chat-side-btn chat-side-btn-small" id="statusBtn">Status</button>
        <button class="chat-side-btn chat-side-btn-small" id="newDmBtn">New DM</button>
        <button class="chat-side-btn chat-side-btn-small" id="profileBtn">Profile</button>
        <button class="chat-side-btn chat-side-btn-small" id="settingsBtn">Settings</button>
      </div>
    </aside>

    <!-- MAIN AREA -->
    <main class="chat-main-area">
      <header class="chat-header">
        <div id="currentChannelLabel">#general</div>
        <div class="chat-header-actions">
          <button id="adminPortalBtn" class="btn btn--small btn--ghost" style="display:none;">Open Admin Portal</button>
          <button id="logoutBtn" class="btn btn--small">Logout</button>
        </div>
      </header>

      <section class="chat-message-list" id="chatMessages"></section>
      <div id="typingIndicator" class="typing-indicator"></div>

      <footer class="chat-bottom-bar">
        <button class="chat-attach-btn" id="attachBtn" title="Attach file">üìé</button>
        <input id="fileInput" type="file" multiple style="display:none;">
        <input id="chatInput" class="input-box chat-input" type="text" placeholder="Message...">
        <button class="chat-send-btn" id="sendBtn">
          <span class="chat-send-arrow"></span>
        </button>
      </footer>
      <div id="attachmentPreview" class="chat-attachment-preview"></div>
    </main>

  </div>

  <!-- Side panel for lists -->
  <div id="sidePanel" class="panel panel--side">
    <button class="panel-close-btn" id="sidePanelCloseBtn" type="button">√ó Close</button>
    <div id="sidePanelContent" class="panel-content"></div>
  </div>

  <!-- DM Search / Create Panel -->
  <div id="dmSearchPanel" class="panel panel--center panel--hidden">
    <div class="panel-title">Start a New DM</div>
    <input id="dmSearchInput"
           class="input-box"
           placeholder="Search username...">
    <div id="dmSearchResults" class="scroll-box"></div>
    <button class="btn btn--wide btn--center" id="dmSearchCloseBtn">Close</button>
  </div>

  <!-- Profile Popup -->
  <div id="profilePopup" class="panel panel--center panel--hidden">
    <div class="profile-header">
      <div id="profileAvatar" class="profile-avatar"></div>
      <div class="profile-name-row">
        <h3 id="profileName"></h3>
        <span id="profileBadge" class="chat-msg-badge profile-badge" hidden>MOD</span>
      </div>
      <div id="profileStatus">Status: unknown</div>
      <div id="profileJoined">Joined: unknown</div>
    </div>

    <div id="profileControls" class="profile-controls">
      <input type="file" id="avatarFile" accept="image/*" style="display:none;">
      <button class="btn btn--wide btn--center"
              id="avatarUploadBtn"
              style="display:none;">
        Upload Avatar...
      </button>
    </div>

    <button class="btn btn--wide btn--center" id="addFriendBtn">
      Add Friend...
    </button>

    <button class="btn btn--wide btn--center" id="dmUserBtn">
      DM User...
    </button>

    <button class="btn btn--wide btn--center" id="profileCloseBtn">
      Close
    </button>
  </div>

  <!-- Link Preview Modal -->
  <div id="linkPreviewModal" class="panel panel--center panel--hidden link-preview-modal">
    <div class="link-preview-modal__row">
      <div id="linkPreviewModalIcon" class="link-preview-icon">üåê</div>
      <div class="link-preview-modal__text">
        <div id="linkPreviewModalTitle" class="link-preview-modal__title">Loading preview...</div>
        <div id="linkPreviewModalUrl" class="link-preview-modal__url"></div>
      </div>
    </div>
    <div class="link-preview-modal__actions">
      <button class="btn btn--wide btn--center" id="linkPreviewOpenBtn">Open Link</button>
      <button class="btn btn--wide btn--center btn--ghost" id="linkPreviewCloseBtn">Close</button>
    </div>
  </div>

  <!-- Toasts -->
  <div id="toastContainer" class="toast-container"></div>

</div>

<script>
/* ============================================================
   GLOBAL STATE
============================================================ */
const API = {
  messages: "/api/messages",
  wsBase: function () {
    const proto = (location.protocol === "https:") ? "wss" : "ws";
    return proto + "://" + location.host;
  }
};

let token = localStorage.getItem("token");
let username = localStorage.getItem("username");
let currentChannel = "general";
let ws = null;
let oldestMessageId = null;
let loadingHistory = false;

let dmListCache = new Set();
let banRedirecting = false;
let authRedirecting = false;
const DEFAULT_UI_SCALE = 1;
const MIN_UI_SCALE = 0.8;
const MAX_UI_SCALE = 1.4;
let userSettings = { theme: "classic", uiScale: DEFAULT_UI_SCALE, language: "en" };
let userSecurity = { email: "", phone: "", twoFactorEnabled: false };
const translations = {
  en: {
    hideSidebar: "Hide Sidebar",
    showSidebar: "Show Sidebar",
    dmList: "DM List",
    channels: "Channels",
    friends: "Friends",
    friendRequests: "Requests",
    online: "Online",
    status: "Status",
    newDm: "New DM",
    profile: "Profile",
    settings: "Settings",
    logout: "Logout",
    messagePlaceholder: "Message...",
    attachTitle: "Attach file",
    settingsTitle: "User Settings",
    settingsTabGeneral: "General",
    settingsTabSecurity: "Security",
    settingsTabAccount: "Account",
    themeLabel: "Theme",
    uiScaleLabel: "UI Scale",
    languageLabel: "Language",
    accountEmailTitle: "Account Email (required)",
    accountEmailPlaceholder: "Email for login + resets",
    phonePlaceholder: "Phone (optional)",
    twofaToggle: "Require 2-step verification",
    saveSecurity: "Save Security Settings",
    tokenTitle: "Session Token",
    resetTokenBtn: "Reset Token (log out other sessions)",
    pwdResetTitle: "Password Reset (email)",
    pwdResetInfo: "Send a reset link to the email on your account. Follow the link to set a new password.",
    resetEmailBtn: "Email me a reset link",
    appLoginTitle: "App Login Code",
    appLoginDescription: "Generate a one-time code to sign into other Benno111 apps.",
    appLoginPlaceholder: "Generate a code to display here",
    generateAppLoginCode: "Generate login code for other apps",
    appLoginExpiresIn: "Expires in {{mins}} minute(s)",
    appLoginReady: "Use this code within the next few minutes.",
    loading: "Working...",
  },
  es: {
    hideSidebar: "Ocultar barra lateral",
    showSidebar: "Mostrar barra lateral",
    dmList: "Lista de MD",
    channels: "Canales",
    friends: "Amigos",
    friendRequests: "Solicitudes",
    online: "En l√≠nea",
    status: "Estado",
    newDm: "Nuevo MD",
    profile: "Perfil",
    settings: "Configuraci√≥n",
    logout: "Cerrar sesi√≥n",
    messagePlaceholder: "Mensaje...",
    attachTitle: "Adjuntar archivo",
    settingsTitle: "Configuraci√≥n de usuario",
    settingsTabGeneral: "General",
    settingsTabSecurity: "Seguridad",
    settingsTabAccount: "Cuenta",
    themeLabel: "Tema",
    uiScaleLabel: "Escala de UI",
    languageLabel: "Idioma",
    accountEmailTitle: "Correo de la cuenta (requerido)",
    accountEmailPlaceholder: "Correo para inicio de sesi√≥n y restablecer",
    phonePlaceholder: "Tel√©fono (opcional)",
    twofaToggle: "Requerir verificaci√≥n en dos pasos",
    saveSecurity: "Guardar seguridad",
    tokenTitle: "Token de sesi√≥n",
    resetTokenBtn: "Restablecer token (cerrar otras sesiones)",
    pwdResetTitle: "Restablecer contrase√±a (correo)",
    pwdResetInfo: "Env√≠a un enlace de restablecimiento al correo de tu cuenta. Sigue el enlace para establecer una nueva contrase√±a.",
    resetEmailBtn: "Env√≠ame un enlace de restablecimiento",
    appLoginTitle: "C√≥digo de inicio de sesi√≥n de app",
    appLoginDescription: "Genera un c√≥digo de un solo uso para iniciar sesi√≥n en otras apps de Benno111.",
    appLoginPlaceholder: "Genera un c√≥digo para mostrar aqu√≠",
    generateAppLoginCode: "Generar c√≥digo para otras apps",
    appLoginExpiresIn: "Caduca en {{mins}} minuto(s)",
    appLoginReady: "Usa este c√≥digo en los pr√≥ximos minutos.",
    loading: "Procesando...",
  },
  fr: {
    hideSidebar: "Masquer le volet",
    showSidebar: "Afficher le volet",
    dmList: "Liste des MP",
    channels: "Canaux",
    friends: "Amis",
    friendRequests: "Demandes",
    online: "En ligne",
    status: "Statut",
    newDm: "Nouveau MP",
    profile: "Profil",
    settings: "Param√®tres",
    logout: "D√©connexion",
    messagePlaceholder: "Message...",
    attachTitle: "Joindre un fichier",
    settingsTitle: "Param√®tres utilisateur",
    settingsTabGeneral: "G√©n√©ral",
    settingsTabSecurity: "S√©curit√©",
    settingsTabAccount: "Compte",
    themeLabel: "Th√®me",
    uiScaleLabel: "√âchelle UI",
    languageLabel: "Langue",
    accountEmailTitle: "Email du compte (requis)",
    accountEmailPlaceholder: "Email pour connexion et r√©initialisation",
    phonePlaceholder: "T√©l√©phone (optionnel)",
    twofaToggle: "Exiger la v√©rification en deux √©tapes",
    saveSecurity: "Enregistrer la s√©curit√©",
    tokenTitle: "Jeton de session",
    resetTokenBtn: "R√©initialiser le jeton (d√©connecter les autres sessions)",
    pwdResetTitle: "R√©initialiser le mot de passe (email)",
    pwdResetInfo: "Envoyez un lien de r√©initialisation √† l'email de votre compte. Suivez le lien pour d√©finir un nouveau mot de passe.",
    resetEmailBtn: "Envoyez-moi un lien de r√©initialisation",
    appLoginTitle: "Code de connexion d'app",
    appLoginDescription: "G√©n√©rez un code √† usage unique pour vous connecter sur d'autres apps Benno111.",
    appLoginPlaceholder: "G√©n√©rez un code √† afficher ici",
    generateAppLoginCode: "G√©n√©rer un code pour d'autres apps",
    appLoginExpiresIn: "Expire dans {{mins}} minute(s)",
    appLoginReady: "Utilisez ce code dans les prochaines minutes.",
    loading: "Traitement...",
  },
  de: {
    hideSidebar: "Seitenleiste ausblenden",
    showSidebar: "Seitenleiste einblenden",
    dmList: "DM-Liste",
    channels: "Kan√§le",
    friends: "Freunde",
    friendRequests: "Anfragen",
    online: "Online",
    status: "Status",
    newDm: "Neue DM",
    profile: "Profil",
    settings: "Einstellungen",
    logout: "Abmelden",
    messagePlaceholder: "Nachricht...",
    attachTitle: "Datei anh√§ngen",
    settingsTitle: "Benutzereinstellungen",
    settingsTabGeneral: "Allgemein",
    settingsTabSecurity: "Sicherheit",
    settingsTabAccount: "Konto",
    themeLabel: "Theme",
    uiScaleLabel: "UI-Skalierung",
    languageLabel: "Sprache",
    accountEmailTitle: "Konto-E-Mail (erforderlich)",
    accountEmailPlaceholder: "E-Mail f√ºr Login und Zur√ºcksetzen",
    phonePlaceholder: "Telefon (optional)",
    twofaToggle: "Zwei-Faktor-Pr√ºfung verlangen",
    saveSecurity: "Sicherheit speichern",
    tokenTitle: "Sitzungstoken",
    resetTokenBtn: "Token zur√ºcksetzen (andere Sitzungen abmelden)",
    pwdResetTitle: "Passwort zur√ºcksetzen (E-Mail)",
    pwdResetInfo: "Sende einen Reset-Link an die E-Mail deines Kontos. Folge dem Link, um ein neues Passwort zu setzen.",
    resetEmailBtn: "Reset-Link per E-Mail senden",
    appLoginTitle: "App-Anmeldecode",
    appLoginDescription: "Erzeuge einen Einmalcode, um dich in anderen Benno111-Apps anzumelden.",
    appLoginPlaceholder: "Hier erscheint dein erzeugter Code",
    generateAppLoginCode: "Code f√ºr andere Apps erzeugen",
    appLoginExpiresIn: "L√§uft in {{mins}} Minute(n) ab",
    appLoginReady: "Nutze diesen Code in den n√§chsten Minuten.",
    loading: "Wird verarbeitet...",
  },
};

const storedLanguage = localStorage.getItem("preferredLanguage");
if (storedLanguage) {
  userSettings.language = storedLanguage;
}

function t(key, fallback) {
  const lang = (userSettings.language || "en").toLowerCase();
  const langPack = translations[lang] || translations.en;
  return langPack[key] || translations.en[key] || fallback || key;
}

function redirectToBanInfo(reason) {
  if (banRedirecting) return;
  banRedirecting = true;
  const reasonText =
    reason && typeof reason === "string" && reason.trim()
      ? reason.trim()
      : "You are banned from Benno111 Chat.";
  localStorage.setItem("banReason", reasonText);
  localStorage.setItem("banUser", username || "");
  const query = new URLSearchParams({
    reason: reasonText,
    user: username || "",
  });
  window.location.href = "/ban_info/?" + query.toString();
}

async function performLogout(skipServer) {
  if (authRedirecting) return;
  authRedirecting = true;
  const preferredLanguage = localStorage.getItem("preferredLanguage");
  const recentAccounts = localStorage.getItem("recentAccounts");
  try {
    if (!skipServer && token) {
      await fetch("/api/logout", {
        method: "POST",
        headers: { Authorization: "Bearer " + token },
      });
    }
  } catch (_) {
    // best-effort
  }
  try {
    if (ws) ws.close();
  } catch (_) {}
  localStorage.clear();
  if (preferredLanguage) localStorage.setItem("preferredLanguage", preferredLanguage);
  if (recentAccounts !== null) localStorage.setItem("recentAccounts", recentAccounts);
  window.location.href = "/";
}

function redirectToLoginPage() {
  performLogout(true);
}

function containsBanLanguage(text) {
  if (!text) return false;
  const lowered = text.toLowerCase();
  return (
    lowered.includes("banned") ||
    lowered.includes("ban ") ||
    lowered.includes(" ban") ||
    lowered.includes("ban.")
  );
}

function applyTheme(theme) {
  document.body.classList.toggle("theme-dark", theme === "dark");
}

function isValidEmail(email) {
  return /^[^@\s]+@[^@\s]+\.[^@\s]+$/.test((email || "").trim());
}

function formatBytes(bytes) {
  if (!bytes || bytes <= 0) return "0 B";
  const units = ["B", "KB", "MB", "GB"];
  const i = Math.min(
    units.length - 1,
    Math.floor(Math.log(bytes) / Math.log(1024))
  );
  const value = bytes / Math.pow(1024, i);
  return value.toFixed(value >= 10 || i === 0 ? 0 : 1) + " " + units[i];
}

function clampUiScale(value) {
  const num = Number(value);
  if (!Number.isFinite(num)) return DEFAULT_UI_SCALE;
  return Math.min(MAX_UI_SCALE, Math.max(MIN_UI_SCALE, num));
}

function setUiScale(scale, options) {
  const safe = clampUiScale(scale);
  if (!options || !options.preview) {
    userSettings.uiScale = safe;
  }
  document.documentElement.style.setProperty("--ui-scale", String(safe));
  return safe;
}

async function loadSettings() {
  try {
    const res = await fetch("/api/settings", {
      headers: { Authorization: "Bearer " + token },
    });
    if (!res.ok) return;
    const data = await res.json();
    if (data && data.theme) {
      userSettings.theme = data.theme;
      applyTheme(data.theme);
    }
    if (data && typeof data.uiScale === "number") {
      setUiScale(data.uiScale);
    }
    if (data && typeof data.language === "string") {
      userSettings.language = data.language;
      localStorage.setItem("preferredLanguage", data.language);
    }
    applyTranslations();
  } catch (e) {
    console.warn("Failed to load settings", e);
  }
}

async function loadSecuritySettings() {
  try {
    const res = await fetch("/api/settings/2fa", {
      headers: { Authorization: "Bearer " + token },
    });
    if (!res.ok) return;
    const data = await res.json();
    userSecurity.email = data.email || "";
    userSecurity.phone = data.phone || "";
    userSecurity.twoFactorEnabled = data.twoFactorEnabled === true;
  } catch (e) {
    console.warn("Failed to load 2FA settings", e);
  }
}

async function persistSettings() {
  try {
    await fetch("/api/settings", {
      method: "POST",
      headers: {
        Authorization: "Bearer " + token,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        theme: userSettings.theme,
        uiScale: userSettings.uiScale,
        language: userSettings.language,
      }),
    });
    localStorage.setItem("preferredLanguage", userSettings.language);
  } catch (e) {
    console.warn("Failed to save settings", e);
  }
}

async function updateTheme(theme) {
  userSettings.theme = theme;
  applyTheme(theme);
  persistSettings();
}

function previewUiScale(scale) {
  setUiScale(scale, { preview: true });
}

function updateUiScale(scale) {
  setUiScale(scale);
  persistSettings();
}

function updateLanguage(language) {
  if (typeof language !== "string" || !language.trim()) return;
  userSettings.language = language;
  localStorage.setItem("preferredLanguage", language);
  persistSettings();
  applyTranslations();
  if (currentPanelMode === "settings") renderSettingsPanel();
  showToast("Language set to " + language.toUpperCase());
}

async function saveTwoFactorSettings(email, phone, twoFactorEnabled) {
  if (!isValidEmail(email)) {
    throw new Error("Valid email is required");
  }
  const body = {
    email: email || "",
    phone: phone || "",
    twoFactorEnabled: !!twoFactorEnabled,
  };
  const res = await fetch("/api/settings/2fa", {
    method: "POST",
    headers: {
      Authorization: "Bearer " + token,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(body),
  });
  if (!res.ok) {
    const data = await res.json().catch(() => ({}));
    throw new Error(data.error || "Failed to save 2FA settings");
  }
  const data = await res.json();
  userSecurity.email = data.email || "";
  userSecurity.phone = data.phone || "";
}

async function loadAdminState() {
  if (!username) return;
  try {
    const res = await fetch(
      "/api/accountSummary?username=" + encodeURIComponent(username),
      {
        headers: {
          Authorization: "Bearer " + token,
        },
      }
    );
    if (!res.ok) return;
    const data = await res.json();
    isAdmin = !!data.isAdmin;
    updateAdminPortalVisibility();
  } catch (e) {
    console.warn("Failed to load admin state", e);
  }
}

function updateAdminPortalVisibility() {
  if (!adminPortalBtn) return;
  adminPortalBtn.style.display = isAdmin ? "" : "none";
}

function openAdminPortal() {
  window.open("/mod/", "_blank", "noopener");
}

async function resetSessionToken() {
  const res = await fetch("/api/settings/resetToken", {
    method: "POST",
    headers: { Authorization: "Bearer " + token },
  });
  const data = await res.json().catch(() => ({}));
  if (!res.ok || !data.token) {
    throw new Error(data.error || "Failed to reset token");
  }
  token = data.token;
  localStorage.setItem("token", token);
  try {
    connectWS();
  } catch (_) {}
  return data;
}

async function requestAppLoginCode() {
  const res = await fetch("/api/app/login/code", {
    method: "POST",
    headers: { Authorization: "Bearer " + token },
  });
  const data = await res.json().catch(() => ({}));
  if (!res.ok || !data.code) {
    throw new Error(data.error || "Failed to generate login code");
  }
  return data;
}

async function checkBanResponse(response) {
  if (!response || response.status !== 403) return;
  try {
    const data = await response.clone().json();
    if (data && (data.reason || containsBanLanguage(data.error || ""))) {
      redirectToBanInfo(data.reason || data.error);
      return;
    }
  } catch (_) {
    // fall through to text parsing
  }
  try {
    const txt = await response.clone().text();
    if (containsBanLanguage(txt)) {
      redirectToBanInfo(txt);
    }
  } catch (_) {
    // ignore
  }
}

const originalFetch = window.fetch.bind(window);
window.fetch = async function (input, init) {
  const resp = await originalFetch(input, init);
  if (resp && resp.status === 401) {
    redirectToLoginPage();
  }
  checkBanResponse(resp).catch(() => {});
  return resp;
};
let friends = [];
let onlineUsers = [];
let currentPanelMode = null;
let unread = {};
let typingTimeout = null;
let lastTypingSent = 0;
let pendingFiles = [];
let prevOnlineFriends = new Set();
let isAdmin = false;
let isModeratorUser = false;
let activeLinkPreviewUrl = "";
let sidebarHidden = false;
let activeLightbox = null;
let settingsCategory = "general";

/* LOGIN CHECK */
if (!token || !username) {
  redirectToLoginPage();
}

applyTheme(userSettings.theme);
setUiScale(userSettings.uiScale);
loadSettings();
loadSecuritySettings();
loadAdminState();

/* DOM REFS */
const chatRoot = document.querySelector(".chat-root");
const chatMainArea = document.querySelector(".chat-main-area");
const chatMessages = document.getElementById("chatMessages");
const typingIndicator = document.getElementById("typingIndicator");
const input = document.getElementById("chatInput");
const sendBtn = document.getElementById("sendBtn");
const attachBtn = document.getElementById("attachBtn");
const fileInput = document.getElementById("fileInput");
const attachmentPreview = document.getElementById("attachmentPreview");
const sidePanelRoot = document.getElementById("sidePanel");
const sidePanel = document.getElementById("sidePanelContent");
const sidePanelCloseBtn = document.getElementById("sidePanelCloseBtn");
const profileBtn = document.getElementById("profileBtn");
const dmSearchPanel = document.getElementById("dmSearchPanel");
const dmSearchInput = document.getElementById("dmSearchInput");
const dmSearchResults = document.getElementById("dmSearchResults");
const dmSearchCloseBtn = document.getElementById("dmSearchCloseBtn");
const profilePopup = document.getElementById("profilePopup");
const currentChannelLabel = document.getElementById("currentChannelLabel");
const adminPortalBtn = document.getElementById("adminPortalBtn");
const chatSidebar = document.getElementById("chatSidebar");
const sidebarToggleBtn = document.getElementById("sidebarToggleBtn");
const linkPreviewModal = document.getElementById("linkPreviewModal");
const linkPreviewModalIcon = document.getElementById("linkPreviewModalIcon");
const linkPreviewModalTitle = document.getElementById("linkPreviewModalTitle");
const linkPreviewModalUrl = document.getElementById("linkPreviewModalUrl");
const linkPreviewOpenBtn = document.getElementById("linkPreviewOpenBtn");
const linkPreviewCloseBtn = document.getElementById("linkPreviewCloseBtn");
updateAdminPortalVisibility();

if (linkPreviewOpenBtn) {
  linkPreviewOpenBtn.addEventListener("click", function () {
    if (!activeLinkPreviewUrl) return;
    window.open(activeLinkPreviewUrl, "_blank", "noopener");
    closeLinkPreviewModal();
  });
}
if (linkPreviewCloseBtn) {
  linkPreviewCloseBtn.addEventListener("click", closeLinkPreviewModal);
}
document.addEventListener("keydown", function (event) {
  if (event.key === "Escape") closeLinkPreviewModal();
});

if (sidebarToggleBtn) {
  sidebarToggleBtn.addEventListener("click", function () {
    setSidebarHidden(!sidebarHidden);
  });
  setSidebarHidden(false);
  applyTranslations();
}

if (sidePanelCloseBtn) {
  sidePanelCloseBtn.addEventListener("click", hidePanel);
}

/* ============================================================
   HELPERS
============================================================ */
function formatTimestamp(ts) {
  const d = new Date(ts);
  const hh = d.getHours().toString().padStart(2, "0");
  const mm = d.getMinutes().toString().padStart(2, "0");
  return hh + ":" + mm;
}

function showToast(text) {
  const container = document.getElementById("toastContainer");
  const box = document.createElement("div");
  box.className = "toast";
  box.textContent = text;
  container.appendChild(box);
  setTimeout(function () {
    if (box.parentNode) box.parentNode.removeChild(box);
  }, 4000);
}

/* Safe text => node */
function makeTextNode(str) {
  return document.createTextNode(str || "");
}

function sanitizeUrlMatch(raw) {
  let url = raw || "";
  let suffix = "";
  const trailing = url.match(/[)\],.!?:;]+$/);
  if (trailing) {
    suffix = trailing[0];
    url = url.slice(0, -suffix.length);
  }
  return { url, suffix };
}

function normalizeUrlScheme(url) {
  return /^https?:\/\//i.test(url) ? url : "https://" + url;
}

function renderMessageText(text) {
  const fragment = document.createDocumentFragment();
  const str = typeof text === "string" ? text : "";
  if (!str) return fragment;

  const urlRegex =
    /\b((?:https?:\/\/)?(?:[a-z0-9-]+\.)+[a-z]{2,}(?::\d+)?(?:\/[^\s<]*)?)/gi;
  let lastIndex = 0;
  let match;

  while ((match = urlRegex.exec(str)) !== null) {
    const start = match.index;
    if (start > lastIndex) {
      fragment.appendChild(makeTextNode(str.slice(lastIndex, start)));
    }

    const { url, suffix } = sanitizeUrlMatch(match[0]);

    if (url) {
      const link = document.createElement("a");
      const href = normalizeUrlScheme(url);
      link.href = href;
      link.target = "_blank";
      link.rel = "noopener noreferrer";
      link.textContent = url;
      setupLinkPreview(link);
      fragment.appendChild(link);
    } else {
      fragment.appendChild(makeTextNode(match[0]));
    }

    if (suffix) {
      fragment.appendChild(makeTextNode(suffix));
    }

    lastIndex = urlRegex.lastIndex;
  }

  if (lastIndex < str.length) {
    fragment.appendChild(makeTextNode(str.slice(lastIndex)));
  }

  return fragment;
}

function setSidebarHidden(hidden) {
  sidebarHidden = !!hidden;
  if (chatRoot) {
    chatRoot.classList.toggle("chat-root--sidebar-hidden", sidebarHidden);
  }
  if (sidebarToggleBtn) {
    sidebarToggleBtn.textContent = sidebarHidden
      ? t("showSidebar", "Show Sidebar")
      : t("hideSidebar", "Hide Sidebar");
  }
}

function applyTranslations() {
  const staticButtons = [
    { id: "serverListBtn", key: "dmList" },
    { id: "channelListBtn", key: "channels" },
    { id: "friendsBtn", key: "friends" },
    { id: "friendsRequestsBtn", key: "friendRequests" },
    { id: "onlineBtn", key: "online" },
    { id: "statusBtn", key: "status" },
    { id: "newDmBtn", key: "newDm" },
    { id: "profileBtn", key: "profile" },
    { id: "settingsBtn", key: "settings" },
    { id: "logoutBtn", key: "logout" },
  ];
  staticButtons.forEach(({ id, key }) => {
    const el = document.getElementById(id);
    if (el) el.textContent = t(key, el.textContent);
  });
  if (sidebarToggleBtn) {
    sidebarToggleBtn.textContent = sidebarHidden
      ? t("showSidebar", "Show Sidebar")
      : t("hideSidebar", "Hide Sidebar");
  }
  if (input) input.placeholder = t("messagePlaceholder", "Message...");
  if (attachBtn) attachBtn.title = t("attachTitle", "Attach file");
}

const IMAGE_EXTENSIONS = [".png", ".jpg", ".jpeg", ".gif", ".webp", ".bmp", ".svg"];
const VIDEO_EXTENSIONS = [".mp4", ".webm", ".ogg"];

function isLikelyImageUrl(url) {
  const lower = (url || "").split("?")[0].split("#")[0].toLowerCase();
  return IMAGE_EXTENSIONS.some(function (ext) {
    return lower.endsWith(ext);
  });
}

function collectImageLinks(text) {
  const list = [];
  if (!text) return list;
  const str = String(text);
  const urlRegex =
    /\b((?:https?:\/\/)?(?:[a-z0-9-]+\.)+[a-z]{2,}(?::\d+)?(?:\/[^\s<]*)?)/gi;
  let match;
  while ((match = urlRegex.exec(str)) !== null) {
    const { url } = sanitizeUrlMatch(match[0]);
    if (!url) continue;
    const href = normalizeUrlScheme(url);
    if (isLikelyImageUrl(href)) {
      list.push(href);
    }
  }
  return list;
}

function buildVideoEmbed(url) {
  let parsed;
  try {
    parsed = new URL(url);
  } catch (e) {
    return null;
  }
  const base = parsed.href;
  const cleanPath = parsed.pathname || "";
  const host = parsed.hostname.toLowerCase();
  const lowerBase = base.split("?")[0].split("#")[0].toLowerCase();

  if (
    VIDEO_EXTENSIONS.some(function (ext) {
      return lowerBase.endsWith(ext);
    })
  ) {
    return { kind: "video", src: base };
  }

  if (host.includes("youtube.com")) {
    let videoId = parsed.searchParams.get("v");
    if (!videoId && cleanPath.startsWith("/embed/")) {
      videoId = cleanPath.split("/")[2];
    } else if (!videoId && cleanPath.startsWith("/shorts/")) {
      videoId = cleanPath.split("/")[2];
    }
    if (videoId) {
      return {
        kind: "iframe",
        src: "https://www.youtube.com/embed/" + videoId,
        title: "YouTube video",
      };
    }
  }
  if (host === "youtu.be") {
    const videoId = cleanPath.replace("/", "");
    if (videoId) {
      return {
        kind: "iframe",
        src: "https://www.youtube.com/embed/" + videoId,
        title: "YouTube video",
      };
    }
  }

  if (host.includes("vimeo.com")) {
    const match = cleanPath.match(/\/(\d+)/);
    if (match && match[1]) {
      return {
        kind: "iframe",
        src: "https://player.vimeo.com/video/" + match[1],
        title: "Vimeo video",
      };
    }
  }

  if (host.includes("streamable.com")) {
    const slug = cleanPath.replace("/", "");
    if (slug) {
      return {
        kind: "iframe",
        src: "https://streamable.com/e/" + slug,
        title: "Streamable video",
      };
    }
  }

  return null;
}

function collectVideoEmbeds(text) {
  const list = [];
  if (!text) return list;
  const str = String(text);
  const urlRegex =
    /\b((?:https?:\/\/)?(?:[a-z0-9-]+\.)+[a-z]{2,}(?::\d+)?(?:\/[^\s<]*)?)/gi;
  let match;
  while ((match = urlRegex.exec(str)) !== null) {
    const { url } = sanitizeUrlMatch(match[0]);
    if (!url) continue;
    const href = normalizeUrlScheme(url);
    const embed = buildVideoEmbed(href);
    if (embed) list.push(embed);
  }
  return list;
}

/* ============================================================
   LINK PREVIEW HELPERS
============================================================ */
const linkPreviewCache = new Map();
const linkPreviewPending = new Map();
let linkTooltipEl = null;
let linkTooltipIconEl = null;
let linkTooltipTitleEl = null;
let linkTooltipHostEl = null;
let linkTooltipTimer = null;
let currentTooltipAnchor = null;
let tooltipPointer = { x: 0, y: 0 };

function normalizePreviewUrl(raw) {
  if (!raw) return "";
  const trimmed = raw.trim();
  if (!trimmed) return "";
  try {
    return new URL(trimmed).toString();
  } catch (_) {}
  try {
    return new URL(/^https?:\/\//i.test(trimmed) ? trimmed : "https://" + trimmed).toString();
  } catch (_) {}
  try {
    return new URL(trimmed, location.origin).toString();
  } catch (e) {
    return "";
  }
}

function createFallbackMeta(url) {
  let host = url;
  try {
    host = new URL(url).hostname;
  } catch (_) {}
  return { url: url, title: host, host: host, favicon: "" };
}

async function fetchLinkPreviewMeta(url) {
  const normalized = normalizePreviewUrl(url);
  if (!normalized) return null;
  if (linkPreviewCache.has(normalized)) return linkPreviewCache.get(normalized);
  if (linkPreviewPending.has(normalized)) return linkPreviewPending.get(normalized);

  const promise = (async function () {
    let timer = null;
    try {
      const controller = new AbortController();
      timer = setTimeout(function () {
        controller.abort();
      }, 5000);
      const resp = await fetch(
        "/api/linkPreview?url=" + encodeURIComponent(normalized),
        { signal: controller.signal }
      );
      clearTimeout(timer);
      if (!resp.ok) throw new Error("preview failed");
      const data = await resp.json().catch(function () {
        return {};
      });
      const host = data.host || new URL(normalized).hostname;
      const meta = {
        url: normalized,
        title: data.title || host,
        host: host,
        favicon: data.favicon || "",
      };
      linkPreviewCache.set(normalized, meta);
      return meta;
    } catch (_) {
      const fallback = createFallbackMeta(normalized);
      linkPreviewCache.set(normalized, fallback);
      return fallback;
    } finally {
      if (timer) clearTimeout(timer);
      linkPreviewPending.delete(normalized);
    }
  })();

  linkPreviewPending.set(normalized, promise);
  return promise;
}

function ensureLinkTooltip() {
  if (linkTooltipEl) return;
  const tooltip = document.createElement("div");
  tooltip.className = "link-tooltip";
  const icon = document.createElement("div");
  icon.className = "link-tooltip__icon";
  icon.textContent = "üåê";
  const text = document.createElement("div");
  text.className = "link-tooltip__text";
  const title = document.createElement("div");
  title.className = "link-tooltip__title";
  const host = document.createElement("div");
  host.className = "link-tooltip__host";
  text.appendChild(title);
  text.appendChild(host);
  tooltip.appendChild(icon);
  tooltip.appendChild(text);
  document.body.appendChild(tooltip);
  linkTooltipEl = tooltip;
  linkTooltipIconEl = icon;
  linkTooltipTitleEl = title;
  linkTooltipHostEl = host;
}

function setLinkIcon(target, iconUrl) {
  if (!target) return;
  if (iconUrl) {
    const safe = iconUrl.replace(/"/g, '\\"');
    target.style.backgroundImage = 'url("' + safe + '")';
    target.textContent = "";
  } else {
    target.style.backgroundImage = "none";
    target.textContent = "üåê";
  }
}

function positionLinkTooltip(x, y) {
  if (!linkTooltipEl) return;
  const offset = 16;
  let left = x + offset;
  let top = y + offset;
  const rect = linkTooltipEl.getBoundingClientRect();
  if (left + rect.width > window.innerWidth - 8) {
    left = window.innerWidth - rect.width - 8;
  }
  if (top + rect.height > window.innerHeight - 8) {
    top = y - rect.height - offset;
  }
  if (top < 4) top = 4;
  if (left < 4) left = 4;
  linkTooltipEl.style.left = left + "px";
  linkTooltipEl.style.top = top + "px";
}

function hideLinkTooltip() {
  if (linkTooltipTimer) {
    clearTimeout(linkTooltipTimer);
    linkTooltipTimer = null;
  }
  if (!linkTooltipEl) return;
  linkTooltipEl.classList.remove("link-tooltip--visible");
  currentTooltipAnchor = null;
}

async function showLinkTooltipForAnchor(anchor) {
  if (!anchor) return;
  ensureLinkTooltip();
  const meta = await fetchLinkPreviewMeta(anchor.href);
  if (!meta || currentTooltipAnchor !== anchor || !linkTooltipEl) return;
  linkTooltipTitleEl.textContent = meta.title || meta.host || meta.url;
  linkTooltipHostEl.textContent = meta.host || meta.url;
  setLinkIcon(linkTooltipIconEl, meta.favicon);
  linkTooltipEl.classList.add("link-tooltip--visible");
  positionLinkTooltip(tooltipPointer.x, tooltipPointer.y);
}

function setupLinkPreview(link) {
  if (!link || link.dataset.previewBound) return;
  link.dataset.previewBound = "1";
  link.addEventListener("mouseenter", function (event) {
    tooltipPointer = { x: event.clientX, y: event.clientY };
    currentTooltipAnchor = event.currentTarget;
    linkTooltipTimer = setTimeout(function () {
      showLinkTooltipForAnchor(event.currentTarget);
    }, 250);
  });
  link.addEventListener("mousemove", function (event) {
    tooltipPointer = { x: event.clientX, y: event.clientY };
    if (linkTooltipEl && linkTooltipEl.classList.contains("link-tooltip--visible")) {
      positionLinkTooltip(event.clientX, event.clientY);
    }
  });
  link.addEventListener("mouseleave", function () {
    hideLinkTooltip();
  });
  link.addEventListener("click", function (event) {
    if (
      event.defaultPrevented ||
      event.button !== 0 ||
      event.metaKey ||
      event.ctrlKey ||
      event.shiftKey ||
      event.altKey
    ) {
      return;
    }
    event.preventDefault();
    hideLinkTooltip();
    openLinkPreviewModal(event.currentTarget);
  });
}

function closeLinkPreviewModal() {
  if (!linkPreviewModal) return;
  linkPreviewModal.classList.add("panel--hidden");
  activeLinkPreviewUrl = "";
}

async function openLinkPreviewModal(linkEl) {
  if (!linkPreviewModal || !linkEl) {
    window.open(linkEl ? linkEl.href : "#", "_blank", "noopener");
    return;
  }
  const targetUrl = linkEl.href;
  activeLinkPreviewUrl = targetUrl;
  linkPreviewModal.classList.remove("panel--hidden");
  linkPreviewModalTitle.textContent = "Loading preview...";
  linkPreviewModalUrl.textContent = targetUrl;
  setLinkIcon(linkPreviewModalIcon, "");
  try {
    const meta = await fetchLinkPreviewMeta(targetUrl);
    if (activeLinkPreviewUrl !== targetUrl) return;
    linkPreviewModalTitle.textContent = meta ? (meta.title || meta.host || targetUrl) : targetUrl;
    linkPreviewModalUrl.textContent = meta ? (meta.host || targetUrl) : targetUrl;
    setLinkIcon(linkPreviewModalIcon, meta ? meta.favicon : "");
  } catch (_) {
    if (activeLinkPreviewUrl !== targetUrl) return;
    linkPreviewModalTitle.textContent = targetUrl;
    linkPreviewModalUrl.textContent = targetUrl;
    setLinkIcon(linkPreviewModalIcon, "");
  }
}

/* ============================================================
   WEBSOCKET
============================================================ */
function connectWS() {
  if (ws) {
    try { ws.close(); } catch (e) {}
  }

  const url = API.wsBase() + "/?token=" + encodeURIComponent(token) +
              "&channel=" + encodeURIComponent(currentChannel);

  ws = new WebSocket(url);

  ws.onopen = function () {
    console.log("WS connected to", currentChannel);
  };

  ws.onmessage = function (event) {
    let data;
    try {
      data = JSON.parse(event.data);
    } catch (e) {
      return;
    }

    if (data.type === "chat") {
      addMessage(data);
    } else if (data.type === "system") {
      if (containsBanLanguage(data.text || "")) {
        redirectToBanInfo(data.text || "Account banned.");
        return;
      }
      addSystemMessage(data.text);
    } else if (data.type === "delete") {
      removeMessage(data.id);
    } else if (data.type === "typing") {
      showTyping(data.user);
    } else if (data.type === "presence_snapshot") {
      onlineUsers = data.users || [];
      if (currentPanelMode === "online") renderOnlineList();
      if (currentPanelMode === "friends") renderFriendsList();
      const nowOnlineFriends = new Set((friends || []).filter(function (f) {
        return onlineUsers.indexOf(f) !== -1;
      }));
      nowOnlineFriends.forEach(function (f) {
        if (!prevOnlineFriends.has(f)) showToast(f + " came online");
      });
      prevOnlineFriends.forEach(function (f) {
        if (!nowOnlineFriends.has(f)) showToast(f + " went offline");
      });
      prevOnlineFriends = nowOnlineFriends;
    } else if (data.type === "friend_request_received") {
      showToast("New friend request from " + data.from);
    } else if (data.type === "friend_request_accepted") {
      showToast(data.by + " accepted your friend request!");
    } else if (data.type === "attachment_delete") {
      if (data.channel && data.channel !== currentChannel) return;
      const el = document.querySelector('[data-attachment-id="' + data.id + '"]');
      if (el && el.parentNode) el.parentNode.removeChild(el);
    }
  };

  ws.onclose = function (event) {
    if (event && event.code === 4003) {
      redirectToBanInfo(event.reason || "Account banned.");
      return;
    }
    if (event && event.code === 4001) {
      redirectToLoginPage();
      return;
    }
    console.warn("WS closed ‚Äî reconnecting in 2s...");
    setTimeout(connectWS, 2000);
  };
}

connectWS();

/* ============================================================
   HISTORY LOADING
============================================================ */
async function loadHistory(initial) {
  if (loadingHistory) return;
  loadingHistory = true;

  const url = new URL(API.messages, location.origin);
  url.searchParams.set("channel", currentChannel);
  url.searchParams.set("limit", "30");
  if (oldestMessageId) url.searchParams.set("beforeId", String(oldestMessageId));

  try {
    const res = await fetch(url.toString(), {
      headers: { Authorization: "Bearer " + token }
    });
    if (!res.ok) {
      loadingHistory = false;
      return;
    }
    const data = await res.json();
    if (initial) chatMessages.innerHTML = "";
    data.messages.forEach(function (msg) {
      prependMessage(msg);
      if (!oldestMessageId || msg.id < oldestMessageId) oldestMessageId = msg.id;
    });
  } catch (e) {
    console.error("History error", e);
  }
  loadingHistory = false;
}

loadHistory(true);

chatMessages.addEventListener("scroll", function () {
  if (chatMessages.scrollTop < 80) {
    loadHistory(false);
  }
});

/* ============================================================
   MESSAGE RENDERING
============================================================ */
function createMessageElement(msg, prepend) {
  const row = document.createElement("div");
  row.className = "chat-msg-row";
  row.dataset.id = msg.id;
  row.dataset.channel = msg.channel || currentChannel;
  row.dataset.user = msg.user || "";
  row.dataset.text = msg.text || "";

  const avatar = document.createElement("div");
  avatar.className = "chat-msg-avatar";
  avatar.style.backgroundImage =
    msg.user ? `url("/avatars/${encodeURIComponent(msg.user)}.png")` : "";
  avatar.title = msg.user || "Unknown";
  avatar.addEventListener("click", function () {
    if (msg.user) openProfile(msg.user);
  });

  const wrapper = document.createElement("div");
  wrapper.className = "chat-msg";

  const userColor = (msg.user === username) ? "#7df" : "#fff";
  const isAdminSender = msg.isAdmin === true;

  // header
  const header = document.createElement("div");
  header.className = "chat-msg-header";

  const userSpan = document.createElement("span");
  userSpan.className = "chat-msg-user";
  userSpan.style.color = userColor;
  userSpan.textContent = isAdminSender ? msg.user + " (admin)" : msg.user;
  userSpan.addEventListener("click", function () {
    openProfile(msg.user);
  });

  const timeSpan = document.createElement("span");
  timeSpan.className = "chat-msg-time";
  timeSpan.textContent = formatTimestamp(msg.ts);

  header.appendChild(userSpan);
  header.appendChild(timeSpan);

  // text
  const body = document.createElement("div");
  body.className = "chat-msg-body";
  body.appendChild(renderMessageText(msg.text));
  const imageLinks = collectImageLinks(msg.text);
  imageLinks.forEach(function (src) {
    const wrapper = document.createElement("div");
    wrapper.className = "chat-msg-image-wrapper";
    const img = document.createElement("img");
    img.className = "chat-msg-image";
    img.src = src;
    img.alt = "Shared image";
    img.loading = "lazy";
    img.decoding = "async";
    img.addEventListener("click", function (e) {
      e.stopPropagation();
      openLightbox(src);
    });
    wrapper.appendChild(img);
    body.appendChild(wrapper);
  });
  const videoEmbeds = collectVideoEmbeds(msg.text);
  videoEmbeds.forEach(function (embed) {
    const wrapper = document.createElement("div");
    wrapper.className = "chat-msg-video-wrapper";
    if (embed.kind === "iframe") {
      const iframe = document.createElement("iframe");
      iframe.className = "chat-msg-video-embed";
      iframe.src = embed.src;
      iframe.title = embed.title || "Embedded video";
      iframe.allow =
        "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
      iframe.allowFullscreen = true;
      wrapper.appendChild(iframe);
    } else {
      const video = document.createElement("video");
      video.className = "chat-msg-video";
      video.src = embed.src;
      video.controls = true;
      video.preload = "metadata";
      video.loading = "lazy";
      video.addEventListener("click", function (event) {
        event.stopPropagation();
      });
      wrapper.appendChild(video);
    }
    body.appendChild(wrapper);
  });

  // actions
  const actions = document.createElement("div");
  actions.className = "msg-actions";

  if (msg.user === username) {
    const delBtn = document.createElement("button");
    delBtn.className = "msg-btn msg-btn--danger";
    delBtn.textContent = "delete";
    delBtn.addEventListener("click", function () {
      deleteMessage(msg.id);
    });
    actions.appendChild(delBtn);
  } else {
    const repBtn = document.createElement("button");
    repBtn.className = "msg-btn msg-btn--warn";
    repBtn.textContent = "report";
    repBtn.addEventListener("click", function () {
      reportMessage(msg.id, msg.user, msg.text);
    });
    actions.appendChild(repBtn);
  }

  wrapper.appendChild(header);
  wrapper.appendChild(body);

  const attachments = Array.isArray(msg.attachments) ? msg.attachments : [];
  if (attachments.length) {
    const list = document.createElement("div");
    list.className = "chat-attachments";
    attachments.forEach((att) => {
      const attContainer = document.createElement("div");
      attContainer.dataset.attachmentId = att.id;
      attContainer.style.position = "relative";
      if (att.isImage) {
        const img = document.createElement("img");
        img.className = "chat-attachment-img";
        img.src = att.url;
        img.alt = att.name || "image";
        img.addEventListener("click", function (e) {
          e.stopPropagation();
          openLightbox(att.url);
        });
        attContainer.appendChild(img);
      } else if (att.isVideo) {
        const video = document.createElement("video");
        video.className = "chat-attachment-video";
        video.src = att.url;
        video.controls = true;
        video.preload = "metadata";
        video.playsInline = true;
        attContainer.appendChild(video);
      } else {
        const link = document.createElement("a");
        link.className = "chat-attachment-link";
        link.href = att.downloadUrl || att.url;
        link.target = "_blank";
        if (att.name) link.download = att.name;
        link.rel = "noreferrer noopener";
        link.textContent = att.name || "Download file";
        const meta = document.createElement("span");
        meta.className = "chat-attachment-link__meta";
        meta.textContent = att.mime ? att.mime + " ‚Ä¢ " + formatBytes(att.size) : formatBytes(att.size);
        link.appendChild(meta);
        attContainer.appendChild(link);
      }

      const actionRow = document.createElement("div");
      actionRow.className = "msg-actions";
      const reportBtn = document.createElement("button");
      reportBtn.className = "msg-btn msg-btn--warn";
      reportBtn.textContent = "report file";
      reportBtn.addEventListener("click", function (e) {
        e.stopPropagation();
        reportAttachment(att);
      });
      actionRow.appendChild(reportBtn);
      if (att.user === username || att.owner === username || msg.user === username) {
        const removeBtn = document.createElement("button");
        removeBtn.className = "msg-btn msg-btn--danger";
        removeBtn.textContent = "remove file";
        removeBtn.addEventListener("click", function (e) {
          e.stopPropagation();
          removeAttachment(att);
        });
        actionRow.appendChild(removeBtn);
      }
      attContainer.appendChild(actionRow);
      list.appendChild(attContainer);
    });
    wrapper.appendChild(list);
  }

  wrapper.appendChild(actions);

  row.appendChild(avatar);
  row.appendChild(wrapper);

  if (prepend) {
    chatMessages.insertBefore(row, chatMessages.firstChild);
  } else {
    chatMessages.appendChild(row);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  if (msg.channel && msg.channel !== currentChannel) {
    unread[msg.channel] = (unread[msg.channel] || 0) + 1;
    updateBadge(msg.channel);
  }
}

function addMessage(msg) {
  createMessageElement(msg, false);
}

function prependMessage(msg) {
  createMessageElement(msg, true);
}

function addSystemMessage(text) {
  const div = document.createElement("div");
  div.className = "chat-system-msg";
  div.appendChild(makeTextNode(text));
  chatMessages.appendChild(div);
}

/* ============================================================
   DELETE + REPORT
============================================================ */
async function deleteMessage(id) {
  try {
    await fetch("/api/deleteMessage", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + token
      },
      body: JSON.stringify({ id: id })
    });
  } catch (e) {
    console.error("Delete failed", e);
  }
}

function removeMessage(id) {
  const el = chatMessages.querySelector('[data-id="' + id + '"]');
  if (el && el.parentNode) el.parentNode.removeChild(el);
}

async function reportAttachment(attachment) {
  const reason = window.prompt("Why are you reporting this file?");
  if (!reason) return;
  try {
    const res = await fetch("/api/reportAttachment", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + token,
      },
      body: JSON.stringify({
        attachmentId: attachment.id,
        offender: attachment.user || attachment.owner || "unknown",
        channel: currentChannel,
        reason: reason,
      }),
    });
    if (res.ok) {
      showToast("Reported file.");
    } else {
      const data = await res.json().catch(() => ({}));
      showToast(data.error || "Failed to report file.");
    }
  } catch (err) {
    console.error("Report attachment error", err);
    showToast("Failed to report file.");
  }
}

async function removeAttachment(attachment) {
  try {
    const res = await fetch("/api/attachment/delete", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + token,
      },
      body: JSON.stringify({ attachmentId: attachment.id }),
    });
    if (res.ok) {
      const el = document.querySelector('[data-attachment-id="' + attachment.id + '"]');
      if (el && el.parentNode) el.parentNode.removeChild(el);
      showToast("File removed.");
    } else {
      const data = await res.json().catch(() => ({}));
      showToast(data.error || "Failed to remove file.");
    }
  } catch (err) {
    console.error("Remove attachment error", err);
    showToast("Failed to remove file.");
  }
}

function openLightbox(src) {
  closeLightbox();
  const overlay = document.createElement("div");
  overlay.className = "lightbox";
  const img = document.createElement("img");
  img.src = src;
  img.alt = "Image preview";
  overlay.appendChild(img);
  overlay.addEventListener("click", closeLightbox);
  document.body.appendChild(overlay);
  activeLightbox = overlay;
}

function closeLightbox() {
  if (activeLightbox && activeLightbox.parentNode) {
    activeLightbox.parentNode.removeChild(activeLightbox);
  }
  activeLightbox = null;
}

async function reportMessage(id, offender, text) {
  const reason = window.prompt("Why are you reporting this message?");
  if (!reason) return;
  try {
    const res = await fetch("/api/reportMessage", {
      method: "POST",
      headers: {
        "Authorization": "Bearer " + token,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        messageId: id,
        offender: offender,
        text: text,
        channel: currentChannel,
        reason: reason
      })
    });
    if (res.ok) {
      showToast("Reported message by " + offender);
    } else {
      const data = await res.json().catch(() => ({}));
      showToast(data.error || "Failed to report message.");
    }
  } catch (e) {
    console.error("Report error", e);
    showToast("Failed to report message.");
  }
}

/* ============================================================
   SENDING + TYPING
============================================================ */
function renderPendingAttachments() {
  if (!attachmentPreview) return;
  attachmentPreview.innerHTML = "";
  if (!pendingFiles.length) return;
  pendingFiles.forEach((file, idx) => {
    const chip = document.createElement("div");
    chip.className = "chat-attachment-preview__item";
    const name = document.createElement("span");
    name.textContent = file.name + " (" + formatBytes(file.size) + ")";
    const remove = document.createElement("button");
    remove.className = "chat-attachment-preview__remove";
    remove.textContent = "√ó";
    remove.addEventListener("click", () => {
      pendingFiles.splice(idx, 1);
      renderPendingAttachments();
    });
    chip.appendChild(name);
    chip.appendChild(remove);
    attachmentPreview.appendChild(chip);
  });
}

function handleFileSelection(list) {
  pendingFiles = Array.from(list || []);
  renderPendingAttachments();
}

if (attachBtn && fileInput) {
  attachBtn.addEventListener("click", () => fileInput.click());
  fileInput.addEventListener("change", () => {
    handleFileSelection(fileInput.files);
  });
}

async function send() {
  const text = input.value.trim().slice(0, 2000);
  const hasFiles = pendingFiles.length > 0;
  if (!text && !hasFiles) return;
  const form = new FormData();
  form.append("channel", currentChannel);
  form.append("text", text);
  pendingFiles.forEach((f) => form.append("files", f));
  sendBtn.disabled = true;
  try {
    const res = await fetch("/api/messages", {
      method: "POST",
      headers: { Authorization: "Bearer " + token },
      body: form,
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok) {
      showToast(data.error || "Failed to send message.");
    } else if (data.message && !chatMessages.querySelector('[data-id="' + data.message.id + '"]')) {
      addMessage(data.message);
    }
  } catch (err) {
    console.error("Send failed", err);
    showToast("Failed to send message.");
  } finally {
    sendBtn.disabled = false;
    input.value = "";
    pendingFiles = [];
    if (fileInput) fileInput.value = "";
    renderPendingAttachments();
  }
}

sendBtn.addEventListener("click", send);
input.addEventListener("keydown", function (e) {
  if (e.key === "Enter") send();
});

input.addEventListener("input", function () {
  const now = Date.now();
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  if (now - lastTypingSent > 1000) {
    ws.send(JSON.stringify({ type: "typing", channel: currentChannel }));
    lastTypingSent = now;
  }
});

function showTyping(user) {
  if (user === username) return;
  typingIndicator.textContent = user + " is typing...";
  if (typingTimeout) {
    clearTimeout(typingTimeout);
  }
  typingTimeout = setTimeout(function () {
    typingIndicator.textContent = "";
  }, 3000);
}

/* ============================================================
   PANEL MANAGEMENT
============================================================ */
function showPanel(mode) {
  currentPanelMode = mode;
  sidePanelRoot.classList.add("panel--visible");
  if (chatRoot) chatRoot.classList.add("chat-root--panel-open");
  sidePanel.innerHTML = "";
  if (mode === "dms") renderDMList();
  else if (mode === "channels") renderChannelList();
  else if (mode === "friends") renderFriendsList();
  else if (mode === "friend_requests") renderFriendRequests();
  else if (mode === "online") renderOnlineList();
  else if (mode === "status") renderStatusPanel();
  else if (mode === "settings") renderSettingsPanel();
}

function hidePanel() {
  currentPanelMode = null;
  sidePanelRoot.classList.remove("panel--visible");
  if (chatRoot) chatRoot.classList.remove("chat-root--panel-open");
}

/* Side buttons */
document.getElementById("serverListBtn").addEventListener("click", function () {
  showPanel("dms");
});
document.getElementById("channelListBtn").addEventListener("click", function () {
  showPanel("channels");
});
document.getElementById("friendsBtn").addEventListener("click", function () {
  showPanel("friends");
});
document.getElementById("friendsRequestsBtn").addEventListener("click", function () {
  showPanel("friend_requests");
});
document.getElementById("onlineBtn").addEventListener("click", function () {
  showPanel("online");
});
if (profileBtn) {
  profileBtn.addEventListener("click", function () {
    if (isAdmin) {
      const target = prompt("Open profile for user:", username) || username;
      openProfile(target.trim() || username);
    } else {
      openProfile(username);
    }
  });
}
document.getElementById("statusBtn").addEventListener("click", function () {
  showPanel("status");
});
document.getElementById("settingsBtn").addEventListener("click", function () {
  showPanel("settings");
});

/* Admin portal */
if (adminPortalBtn) {
  adminPortalBtn.addEventListener("click", function () {
    openAdminPortal();
  });
}

/* Logout */
document.getElementById("logoutBtn").addEventListener("click", function () {
  localStorage.removeItem("autoLoginUser");
  localStorage.removeItem("autoLoginPass");
  performLogout(false);
});

/* ============================================================
   CHANNELS
============================================================ */
const CHANNELS = ["general", "rules", "announcements", "offtopic"];

function renderChannelList() {
  const title = document.createElement("h3");
  title.textContent = "Channels";
  sidePanel.appendChild(title);

  CHANNELS.forEach(function (ch) {
    const row = document.createElement("div");
    row.className = "panel-row";
    const label = document.createElement("span");
    label.textContent = "#" + ch;

    const badge = document.createElement("span");
    badge.id = "badge_" + ch;
    badge.className = "badge badge--hidden";

    row.appendChild(label);
    row.appendChild(badge);

    row.addEventListener("click", function () {
      unread[ch] = 0;
      updateBadge(ch);
      hidePanel();
      switchChannel(ch);
    });

    sidePanel.appendChild(row);
  });
}

function updateBadge(channel) {
  const badge = document.getElementById("badge_" + channel);
  if (!badge) return;
  const count = unread[channel] || 0;
  if (count > 0) {
    badge.textContent = String(count);
    badge.classList.remove("badge--hidden");
  } else {
    badge.classList.add("badge--hidden");
  }
}

function switchChannel(ch) {
  currentChannel = ch;
  currentChannelLabel.textContent = "#" + ch;
  oldestMessageId = null;
  chatMessages.innerHTML = "";
  connectWS();
  loadHistory(true);
}

/* ============================================================
   DMS
============================================================ */
function isDMChannel(name) {
  return name.indexOf("dm:") === 0;
}

function readableDM(name) {
  const users = name.slice(3).split(",");
  for (let i = 0; i < users.length; i++) {
    if (users[i] !== username) return users[i];
  }
  return users[0] || name;
}

async function loadDMs() {
  dmListCache.clear();
  const url = new URL(API.messages, location.origin);
  url.searchParams.set("channel", "general");
  url.searchParams.set("limit", "200");

  const res = await fetch(url.toString(), {
    headers: { Authorization: "Bearer " + token }
  });
  if (!res.ok) return;
  const data = await res.json();

  data.messages.forEach(function (msg) {
    if (msg.channel && isDMChannel(msg.channel)) {
      dmListCache.add(msg.channel);
    }
  });
}

function renderDMList() {
  const title = document.createElement("h3");
  title.textContent = "DMs";
  sidePanel.appendChild(title);

  if (!dmListCache.size) {
    const empty = document.createElement("div");
    empty.className = "panel-empty";
    empty.textContent = "no dms yet...";
    sidePanel.appendChild(empty);
    return;
  }

  dmListCache.forEach(function (ch) {
    const otherUser = readableDM(ch);
    const row = document.createElement("div");
    row.className = "panel-row";
    row.textContent = "DM with " + otherUser;
    row.addEventListener("click", function () {
      hidePanel();
      switchChannel(ch);
    });
    sidePanel.appendChild(row);
  });
}

function openDM(user) {
  if (user === username) return;
  const ch = "dm:" + username + "," + user;
  dmListCache.add(ch);
  switchChannel(ch);
}

/* DM SEARCH */
let allUsers = [];

async function fetchUserList() {
  const set = new Set();
  friends.forEach(function (f) { set.add(f); });
  onlineUsers.forEach(function (u) { set.add(u); });
  set.add(username);
  allUsers = Array.from(set);
}

function openDmSearch() {
  fetchUserList();
  dmSearchPanel.classList.remove("panel--hidden");
  dmSearchInput.value = "";
  renderDmSearch("");
  dmSearchInput.focus();
}

function closeDmSearch() {
  dmSearchPanel.classList.add("panel--hidden");
}

dmSearchInput.addEventListener("input", function () {
  renderDmSearch(dmSearchInput.value.toLowerCase());
});
dmSearchCloseBtn.addEventListener("click", closeDmSearch);
document.getElementById("newDmBtn").addEventListener("click", openDmSearch);

function renderDmSearch(query) {
  dmSearchResults.innerHTML = "";
  const matches = allUsers.filter(function (u) {
    return u.toLowerCase().indexOf(query) !== -1 && u !== username;
  });
  if (!matches.length) {
    const row = document.createElement("div");
    row.className = "panel-empty";
    row.textContent = "No results...";
    dmSearchResults.appendChild(row);
    return;
  }
  matches.forEach(function (user) {
    const row = document.createElement("div");
    row.className = "panel-row panel-row--clickable";
    row.textContent = "Start DM with " + user;
    row.addEventListener("click", function () {
      startDM(user);
    });
    dmSearchResults.appendChild(row);
  });
}

function startDM(target) {
  const ch = "dm:" + username + "," + target;
  dmListCache.add(ch);
  closeDmSearch();
  switchChannel(ch);
}

/* ============================================================
   FRIENDS & ONLINE
============================================================ */
async function fetchFriends() {
  try {
    const res = await fetch("/api/friends", {
      headers: { "Authorization": "Bearer " + token }
    });
    if (!res.ok) return;
    const data = await res.json();
    friends = data.friends || [];
  } catch (e) {
    console.error("friends error", e);
  }
}

async function addFriend(friend) {
  try {
    await fetch("/api/friends/add", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + token
      },
      body: JSON.stringify({ friend: friend })
    });
    await fetchFriends();
    renderFriendsList();
  } catch (e) {
    console.error("addFriend error", e);
  }
}

async function removeFriend(friend) {
  try {
    await fetch("/api/friends/remove", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + token
      },
      body: JSON.stringify({ friend: friend })
    });
    await fetchFriends();
    renderFriendsList();
  } catch (e) {
    console.error("removeFriend error", e);
  }
}

async function renderFriendsList() {
  await fetchFriends();
  sidePanel.innerHTML = "";
  const title = document.createElement("h3");
  title.textContent = "Friends";
  sidePanel.appendChild(title);

  const addBtn = document.createElement("button");
  addBtn.className = "btn";
  addBtn.textContent = "Add friend...";
  addBtn.addEventListener("click", function () {
    const name = window.prompt("Add friend by username:");
    if (name && name !== username) addFriend(name.trim());
  });
  sidePanel.appendChild(addBtn);

  if (!friends.length) {
    const empty = document.createElement("div");
    empty.className = "panel-empty";
    empty.textContent = "no friends yet...";
    sidePanel.appendChild(empty);
    return;
  }

  friends.forEach(function (f) {
    const row = document.createElement("div");
    row.className = "panel-row panel-row--friend";

    const isOnline = onlineUsers.indexOf(f) !== -1;

    const left = document.createElement("div");
    left.className = "panel-row-left";
    const dot = document.createElement("span");
    dot.className = "status-dot " + (isOnline ? "status-online" : "status-offline");
    const nameSpan = document.createElement("span");
    nameSpan.textContent = f;

    left.appendChild(dot);
    left.appendChild(nameSpan);

    const right = document.createElement("div");
    right.className = "panel-row-right";

    const dmBtn = document.createElement("button");
    dmBtn.className = "btn btn--tiny";
    dmBtn.textContent = "DM";
    dmBtn.addEventListener("click", function () {
      const ch = "dm:" + username + "," + f;
      dmListCache.add(ch);
      switchChannel(ch);
      hidePanel();
    });

    const rmBtn = document.createElement("button");
    rmBtn.className = "btn btn--tiny btn--danger";
    rmBtn.textContent = "X";
    rmBtn.addEventListener("click", function () {
      removeFriend(f);
    });

    right.appendChild(dmBtn);
    right.appendChild(rmBtn);

    row.appendChild(left);
    row.appendChild(right);
    sidePanel.appendChild(row);
  });
}

async function fetchOnlineUsers() {
  try {
    const res = await fetch("/api/onlineUsers", {
      headers: { "Authorization": "Bearer " + token }
    });
    if (!res.ok) return;
    const data = await res.json();
    onlineUsers = data.users || [];
  } catch (e) {
    console.error("online error", e);
  }
}

async function renderOnlineList() {
  await fetchOnlineUsers();
  sidePanel.innerHTML = "";
  const title = document.createElement("h3");
  title.textContent = "Online";
  sidePanel.appendChild(title);

  if (!onlineUsers.length) {
    const empty = document.createElement("div");
    empty.className = "panel-empty";
    empty.textContent = "no one online...";
    sidePanel.appendChild(empty);
    return;
  }

  onlineUsers.forEach(function (u) {
    const row = document.createElement("div");
    row.className = "panel-row panel-row--friend";

    const left = document.createElement("div");
    left.className = "panel-row-left";
    const dot = document.createElement("span");
    dot.className = "status-dot status-online";
    const nameSpan = document.createElement("span");
    nameSpan.textContent = u;
    left.appendChild(dot);
    left.appendChild(nameSpan);

    const right = document.createElement("div");
    right.className = "panel-row-right";

    const profBtn = document.createElement("button");
    profBtn.className = "btn btn--tiny";
    profBtn.textContent = "profile";
    profBtn.addEventListener("click", function () {
      openProfile(u);
    });

    const dmBtn = document.createElement("button");
    dmBtn.className = "btn btn--tiny";
    dmBtn.textContent = "DM";
    dmBtn.addEventListener("click", function () {
      const ch = "dm:" + username + "," + u;
      dmListCache.add(ch);
      switchChannel(ch);
      hidePanel();
    });

    right.appendChild(profBtn);
    right.appendChild(dmBtn);

    row.appendChild(left);
    row.appendChild(right);
    sidePanel.appendChild(row);
  });
}

/* FRIEND REQUESTS */
async function renderFriendRequests() {
  try {
    const res = await fetch("/api/friends/requests", {
      headers: { "Authorization": "Bearer " + token }
    });
    if (!res.ok) return;
    const data = await res.json();
    sidePanel.innerHTML = "";
    const title = document.createElement("h3");
    title.textContent = "Friend Requests";
    sidePanel.appendChild(title);

    if (data.incoming && data.incoming.length) {
      const h = document.createElement("h4");
      h.textContent = "Incoming:";
      sidePanel.appendChild(h);
      data.incoming.forEach(function (u) {
        const row = document.createElement("div");
        row.className = "panel-row panel-row--friend";
        const left = document.createElement("div");
        left.textContent = u;
        const right = document.createElement("div");

        const acc = document.createElement("button");
        acc.className = "btn btn--tiny";
        acc.textContent = "‚úî";
        acc.addEventListener("click", function () {
          acceptRequest(u);
        });

        const dec = document.createElement("button");
        dec.className = "btn btn--tiny btn--danger";
        dec.textContent = "‚úñ";
        dec.addEventListener("click", function () {
          declineRequest(u);
        });

        right.appendChild(acc);
        right.appendChild(dec);

        row.appendChild(left);
        row.appendChild(right);
        sidePanel.appendChild(row);
      });
    }

    if (data.outgoing && data.outgoing.length) {
      const h2 = document.createElement("h4");
      h2.textContent = "Outgoing:";
      sidePanel.appendChild(h2);
      data.outgoing.forEach(function (u) {
        const row = document.createElement("div");
        row.className = "panel-row";
        row.textContent = "Pending: " + u;
        sidePanel.appendChild(row);
      });
    }
  } catch (e) {
    console.error("friend req error", e);
  }
}

async function acceptRequest(user) {
  await fetch("/api/friends/accept", {
    method: "POST",
    headers: {
      "Authorization": "Bearer " + token,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ from: user })
  });
  renderFriendRequests();
}

async function declineRequest(user) {
  await fetch("/api/friends/decline", {
    method: "POST",
    headers: {
      "Authorization": "Bearer " + token,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ from: user })
  });
  renderFriendRequests();
}

/* ============================================================
   STATUS PANEL
============================================================ */
function renderStatusPanel() {
  sidePanel.innerHTML = "";
  const title = document.createElement("h3");
  title.textContent = "Status";
  sidePanel.appendChild(title);

  const states = [
    { id: "online", label: "Online üü¢" },
    { id: "idle", label: "Idle üü°" },
    { id: "dnd", label: "Do Not Disturb üî¥" },
    { id: "invisible", label: "Invisible ‚ö´" }
  ];
  states.forEach(function (s) {
    const btn = document.createElement("button");
    btn.className = "btn btn--wide btn--center";
    btn.textContent = s.label;
    btn.addEventListener("click", function () {
      setStatus(s.id, "");
    });
    sidePanel.appendChild(btn);
  });

  const box = document.createElement("input");
  box.placeholder = "custom status‚Ä¶";
  box.className = "input-box";
  box.style.width = "100%";

  const setBtn = document.createElement("button");
  setBtn.className = "btn btn--wide btn--center";
  setBtn.textContent = "Set Custom";
  setBtn.addEventListener("click", function () {
    setStatus("online", box.value);
  });

  sidePanel.appendChild(box);
  sidePanel.appendChild(setBtn);
}

async function setStatus(state, message) {
  await fetch("/api/status", {
    method: "POST",
    headers: {
      "Authorization": "Bearer " + token,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ state: state, message: message })
  });
  hidePanel();
}

function renderSettingsPanel() {
  sidePanel.innerHTML = "";
  const title = document.createElement("h3");
  title.textContent = t("settingsTitle", "User Settings");
  sidePanel.appendChild(title);

  const tabs = document.createElement("div");
  tabs.className = "settings-tabs";
  const categories = [
    { id: "general", label: t("settingsTabGeneral", "General") },
    { id: "security", label: t("settingsTabSecurity", "Security") },
    { id: "account", label: t("settingsTabAccount", "Account") },
  ];
  categories.forEach((cat) => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className =
      "settings-tab" + (settingsCategory === cat.id ? " settings-tab--active" : "");
    btn.textContent = cat.label;
    btn.addEventListener("click", () => {
      settingsCategory = cat.id;
      renderSettingsPanel();
    });
    tabs.appendChild(btn);
  });
  sidePanel.appendChild(tabs);

  const divider = document.createElement("hr");
  divider.style.margin = "12px 0";
  divider.style.opacity = 0.6;

  if (settingsCategory === "general") {
    const themeLabel = document.createElement("p");
    themeLabel.textContent = t("themeLabel", "Theme");
    sidePanel.appendChild(themeLabel);

    const themes = [
      { id: "classic", label: "Classic" },
      { id: "dark", label: "Dark" },
    ];

    themes.forEach(function (option) {
      const btn = document.createElement("button");
      btn.className = "btn btn--wide btn--center";
      btn.textContent =
        option.label +
        (userSettings.theme === option.id ? " ‚úì" : "");
      btn.addEventListener("click", function () {
        updateTheme(option.id);
        renderSettingsPanel();
        showToast("Theme set to " + option.label);
      });
      sidePanel.appendChild(btn);
    });

    const scaleLabel = document.createElement("p");
    scaleLabel.textContent = t("uiScaleLabel", "UI Scale");
    sidePanel.appendChild(scaleLabel);

    const scaleValue = document.createElement("div");
    scaleValue.className = "settings-scale-value";
    scaleValue.textContent = userSettings.uiScale.toFixed(2) + "x";
    sidePanel.appendChild(scaleValue);

    const scaleSlider = document.createElement("input");
    scaleSlider.type = "range";
    scaleSlider.min = String(MIN_UI_SCALE);
    scaleSlider.max = String(MAX_UI_SCALE);
    scaleSlider.step = "0.05";
    scaleSlider.value = String(userSettings.uiScale);
    scaleSlider.className = "settings-scale-slider";
    scaleSlider.addEventListener("input", function () {
      const preview = clampUiScale(scaleSlider.value);
      scaleValue.textContent = preview.toFixed(2) + "x";
      previewUiScale(preview);
    });
    scaleSlider.addEventListener("change", function () {
      updateUiScale(scaleSlider.value);
      scaleValue.textContent = userSettings.uiScale.toFixed(2) + "x";
    });
    sidePanel.appendChild(scaleSlider);

    sidePanel.appendChild(divider.cloneNode());

    const langLabel = document.createElement("p");
    langLabel.textContent = t("languageLabel", "Language");
    sidePanel.appendChild(langLabel);

    const langSelect = document.createElement("select");
    langSelect.className = "input-box";
    [
      { id: "en", label: "English" },
      { id: "es", label: "Espa√±ol" },
      { id: "fr", label: "Fran√ßais" },
      { id: "de", label: "Deutsch" },
    ].forEach((opt) => {
      const option = document.createElement("option");
      option.value = opt.id;
      option.textContent = opt.label;
      if (userSettings.language === opt.id) option.selected = true;
      langSelect.appendChild(option);
    });
    langSelect.addEventListener("change", function () {
      updateLanguage(langSelect.value);
    });
    sidePanel.appendChild(langSelect);
  } else if (settingsCategory === "security") {
    const twofaTitle = document.createElement("h4");
    twofaTitle.textContent = t("accountEmailTitle", "Account Email (required)");
    sidePanel.appendChild(twofaTitle);

    const twofaEmail = document.createElement("input");
    twofaEmail.type = "email";
    twofaEmail.placeholder = t("accountEmailPlaceholder", "Email for login + resets");
    twofaEmail.className = "input-box";
    twofaEmail.value = userSecurity.email || "";
    sidePanel.appendChild(twofaEmail);

    const twofaPhone = document.createElement("input");
    twofaPhone.type = "tel";
    twofaPhone.placeholder = t("phonePlaceholder", "Phone (optional)");
    twofaPhone.className = "input-box";
    twofaPhone.value = userSecurity.phone || "";
    sidePanel.appendChild(twofaPhone);

    const twofaToggleRow = document.createElement("div");
    twofaToggleRow.style.display = "flex";
    twofaToggleRow.style.alignItems = "center";
    twofaToggleRow.style.gap = "8px";
    const twofaToggle = document.createElement("input");
    twofaToggle.type = "checkbox";
    twofaToggle.checked = userSecurity.twoFactorEnabled === true;
    const twofaToggleLabel = document.createElement("label");
    twofaToggleLabel.textContent = t("twofaToggle", "Require 2-step verification");
    twofaToggleRow.appendChild(twofaToggle);
    twofaToggleRow.appendChild(twofaToggleLabel);
    sidePanel.appendChild(twofaToggleRow);

    const twofaStatus = document.createElement("div");
    twofaStatus.className = "auth-status";
    sidePanel.appendChild(twofaStatus);

    const twofaSave = document.createElement("button");
    twofaSave.className = "btn btn--wide btn--center";
    twofaSave.textContent = t("saveSecurity", "Save Security Settings");
    twofaSave.addEventListener("click", async function () {
      twofaStatus.textContent = "Saving...";
      twofaStatus.classList.remove("auth-status--error");
      try {
        await saveTwoFactorSettings(
          twofaEmail.value.trim(),
          twofaPhone.value.trim(),
          twofaToggle.checked
        );
        userSecurity.twoFactorEnabled = twofaToggle.checked;
        twofaStatus.textContent = "Updated!";
      } catch (err) {
        twofaStatus.textContent = err.message || "Failed to save";
        twofaStatus.classList.add("auth-status--error");
      }
    });
    sidePanel.appendChild(twofaSave);

    sidePanel.appendChild(divider.cloneNode());

    const tokenTitle = document.createElement("h4");
    tokenTitle.textContent = t("tokenTitle", "Session Token");
    sidePanel.appendChild(tokenTitle);

    const tokenStatus = document.createElement("div");
    tokenStatus.className = "auth-status";
    sidePanel.appendChild(tokenStatus);

    const resetTokenBtn = document.createElement("button");
    resetTokenBtn.className = "btn btn--wide btn--center";
    resetTokenBtn.textContent = t("resetTokenBtn", "Reset Token (log out other sessions)");
    resetTokenBtn.addEventListener("click", async function () {
      resetTokenBtn.disabled = true;
      tokenStatus.textContent = "Resetting token...";
      tokenStatus.classList.remove("auth-status--error");
      try {
        const result = await resetSessionToken();
        tokenStatus.textContent =
          "Token reset. " +
          (result && typeof result.revoked === "number"
            ? result.revoked + " old session(s) removed."
            : "Old sessions removed.");
        showToast("New session token issued.");
      } catch (err) {
        tokenStatus.textContent = err.message || "Failed to reset token.";
        tokenStatus.classList.add("auth-status--error");
      } finally {
        resetTokenBtn.disabled = false;
      }
    });
    sidePanel.appendChild(resetTokenBtn);

    sidePanel.appendChild(divider.cloneNode());

    const appLoginTitle = document.createElement("h4");
    appLoginTitle.textContent = t("appLoginTitle", "App Login Code");
    sidePanel.appendChild(appLoginTitle);

    const appLoginInfo = document.createElement("p");
    appLoginInfo.textContent = t(
      "appLoginDescription",
      "Generate a one-time code to sign into other Benno111 apps."
    );
    sidePanel.appendChild(appLoginInfo);

    const appLoginCode = document.createElement("input");
    appLoginCode.className = "input-box";
    appLoginCode.readOnly = true;
    appLoginCode.placeholder = t(
      "appLoginPlaceholder",
      "Generate a code to display here"
    );
    sidePanel.appendChild(appLoginCode);

    const appLoginStatus = document.createElement("div");
    appLoginStatus.className = "auth-status";
    sidePanel.appendChild(appLoginStatus);

    const appLoginBtn = document.createElement("button");
    appLoginBtn.className = "btn btn--wide btn--center";
    appLoginBtn.textContent = t(
      "generateAppLoginCode",
      "Generate login code for other apps"
    );
    appLoginBtn.addEventListener("click", async function () {
      appLoginBtn.disabled = true;
      appLoginStatus.textContent = t("loading", "Working...");
      appLoginStatus.classList.remove("auth-status--error");
      try {
        const result = await requestAppLoginCode();
        appLoginCode.value = result.code || "";
        const minutesLeft = result.expiresAt
          ? Math.max(1, Math.round((result.expiresAt - Date.now()) / 60000))
          : null;
        appLoginStatus.textContent = minutesLeft
          ? t("appLoginExpiresIn", "Expires in {{mins}} minute(s)").replace(
              "{{mins}}",
              minutesLeft
            )
          : t("appLoginReady", "Use this code within the next few minutes.");
      } catch (err) {
        appLoginStatus.textContent = err.message || "Failed to generate code";
        appLoginStatus.classList.add("auth-status--error");
      } finally {
        appLoginBtn.disabled = false;
      }
    });
    sidePanel.appendChild(appLoginBtn);
  } else if (settingsCategory === "account") {
    const pwdTitle = document.createElement("h4");
    pwdTitle.textContent = t("pwdResetTitle", "Password Reset (email)");
    sidePanel.appendChild(pwdTitle);

    const pwdInfo = document.createElement("p");
    pwdInfo.textContent = t(
      "pwdResetInfo",
      "Send a reset link to the email on your account. Follow the link to set a new password."
    );
    sidePanel.appendChild(pwdInfo);

    const pwdStatus = document.createElement("div");
    pwdStatus.className = "auth-status";
    sidePanel.appendChild(pwdStatus);

    const pwdBtn = document.createElement("button");
    pwdBtn.className = "btn btn--wide btn--center";
    pwdBtn.textContent = t("resetEmailBtn", "Email me a reset link");
    pwdBtn.addEventListener("click", async function () {
      if (!username) {
        pwdStatus.textContent = "Not signed in.";
        pwdStatus.classList.add("auth-status--error");
        return;
      }
      pwdBtn.disabled = true;
      pwdStatus.textContent = "Requesting reset email...";
      pwdStatus.classList.remove("auth-status--error");
      try {
        const res = await fetch("/api/password/reset/request", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ username }),
        });
        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          throw new Error(data.error || "Failed to request reset.");
        }
        pwdStatus.textContent =
          "If your account has an email, a reset link has been sent.";
      } catch (err) {
        pwdStatus.textContent = err.message || "Failed to request reset.";
        pwdStatus.classList.add("auth-status--error");
      } finally {
        pwdBtn.disabled = false;
      }
    });
    sidePanel.appendChild(pwdBtn);
  }
}

/* ============================================================
   PROFILE POPUP & AVATARS
============================================================ */
function openProfile(user) {
  profilePopup.classList.remove("panel--hidden");
  profilePopup.classList.remove("profile-popup--banned");
  document.getElementById("profileAvatar").classList.remove("profile-avatar--hidden");

  document.getElementById("profileName").textContent = user;
  const avatarDiv = document.getElementById("profileAvatar");
  const profileStatusEl = document.getElementById("profileStatus");
  const profileJoinedEl = document.getElementById("profileJoined");
  const profileNameEl = document.getElementById("profileName");
  const profileBadgeEl = document.getElementById("profileBadge");
  const dmUserBtn = document.getElementById("dmUserBtn");
  const addFriendBtn = document.getElementById("addFriendBtn");
  const avatarUploadBtn = document.getElementById("avatarUploadBtn");
  const avatarFileInput = document.getElementById("avatarFile");

  profileStatusEl.textContent = "Status: unknown";
  profileJoinedEl.textContent = "Joined: unknown";
  dmUserBtn.disabled = false;
  dmUserBtn.textContent = "DM User...";
  dmUserBtn.style.display = "block";
  addFriendBtn.disabled = false;
  addFriendBtn.textContent = "Add Friend...";
  addFriendBtn.style.display = "block";
  profileJoinedEl.style.display = "block";
  profileJoinedEl.textContent = "Joined: unknown";
  profileNameEl.style.color = "";
const setProfileName = (isAdminTarget) => {
    if (!profileNameEl) return;
    profileNameEl.textContent = isAdminTarget ? user + " (admin)" : user;
  };
  setProfileName(false);
  const setProfileBadge = (isAdminTarget) => {
    if (!profileBadgeEl) return;
    if (!isModeratorUser) {
      profileBadgeEl.hidden = true;
      profileBadgeEl.style.display = "none";
      return;
    }
    if (isAdminTarget) {
      profileBadgeEl.textContent = "ADMIN";
      profileBadgeEl.hidden = false;
      profileBadgeEl.style.display = "inline-flex";
    } else {
      profileBadgeEl.hidden = true;
      profileBadgeEl.style.display = "none";
    }
  };
  setProfileBadge(false);
  avatarDiv.style.backgroundImage = "url('/avatars/" + user + ".png?" + Date.now() + "')";

  fetch("/api/status?user=" + encodeURIComponent(user) + "&includeAdmin=1", {
    headers: { "Authorization": "Bearer " + token }
  })
    .then(function (r) {
      if (!r.ok) {
        profileStatusEl.textContent = "User not found";
        profileJoinedEl.textContent = "Joined: unavailable";
        profileJoinedEl.style.display = "block";
        profileNameEl.style.color = "#ffffff";
        avatarDiv.style.backgroundImage = "";
        avatarDiv.classList.add("profile-avatar--hidden");
        dmUserBtn.disabled = true;
        dmUserBtn.textContent = "Unavailable";
        dmUserBtn.style.display = "none";
        addFriendBtn.disabled = true;
        addFriendBtn.textContent = "Unavailable";
        addFriendBtn.style.display = "none";
        return null;
      }
      return r.json();
    })
    .then(function (st) {
      if (!st) return;
      if (st.banned) {
        profilePopup.classList.add("profile-popup--banned");
        profileStatusEl.textContent = "Status: BANNED";
        const cleanedReason = (st.banReason || "")
          .replace(/^Report reason:\s*/i, "")
          .replace(/^Ban reason:\s*/i, "")
          .trim();
        profileJoinedEl.textContent =
          "Ban reason: " + (cleanedReason || "Banned");
        profileJoinedEl.style.display = "block";
        profileNameEl.style.color = "#ffffff";
        setProfileName(false);
        avatarDiv.style.backgroundImage = "";
        avatarDiv.classList.add("profile-avatar--hidden");
        dmUserBtn.disabled = true;
        dmUserBtn.textContent = "User is banned";
        dmUserBtn.style.display = "none";
        addFriendBtn.disabled = true;
        addFriendBtn.textContent = "Unavailable";
        addFriendBtn.style.display = "none";
        setProfileBadge(false);
        return;
      }
      let dot = "‚ö™";
      if (st.state === "online") dot = "üü¢";
      else if (st.state === "idle") dot = "üü°";
      else if (st.state === "dnd") dot = "üî¥";
      else if (st.state === "invisible") dot = "‚ö´";
      profileStatusEl.textContent =
        "Status: " + dot + " " + (st.message || "");
      if (st.joined) {
        profileJoinedEl.textContent =
          "Joined: " + new Date(st.joined).toLocaleDateString();
      } else {
        profileJoinedEl.textContent = "Joined: unknown";
      }
      setProfileName(st.isAdmin === true);
      setProfileBadge(st.isAdmin === true);
      fetch("/api/accountSummary?username=" + encodeURIComponent(user), {
        headers: { Authorization: "Bearer " + token },
      })
        .then((res) => (res.ok ? res.json() : null))
        .then((summary) => {
          if (!summary || !isModeratorUser) return;
          let badgeEl = document.getElementById("profileBadge");
          const isAdminTarget = summary.isAdmin === true;
          if (isAdminTarget) {
            if (!badgeEl) {
              const row = document.querySelector(".profile-name-row");
              if (row) {
                badgeEl = document.createElement("span");
                badgeEl.id = "profileBadge";
                badgeEl.className = "chat-msg-badge profile-badge";
                row.appendChild(badgeEl);
              }
            }
            if (badgeEl) {
              badgeEl.textContent = "ADMIN";
              setProfileBadge(true);
            }
          } else if (badgeEl) {
            setProfileName(false);
            setProfileBadge(false);
          }
        })
        .catch(() => {});
    })
    .catch(function () {});

  dmUserBtn.onclick = function () {
    if (dmUserBtn.disabled) return;
    const ch = "dm:" + username + "," + user;
    dmListCache.add(ch);
    switchChannel(ch);
    closeProfile();
  };

  if (user === username) avatarUploadBtn.style.display = "block";
  else avatarUploadBtn.style.display = "none";

  avatarUploadBtn.onclick = function () {
    avatarFileInput.click();
  };

  avatarFileInput.onchange = async function () {
    const file = avatarFileInput.files[0];
    if (!file) return;
    const formData = new FormData();
    formData.append("avatar", file);
    const res = await fetch("/api/avatar", {
      method: "POST",
      headers: { "Authorization": "Bearer " + token },
      body: formData
    });
    if (res.ok) {
      avatarDiv.style.backgroundImage =
        "url('/avatars/" + user + ".png?" + Date.now() + "')";
      showToast("Avatar updated!");
    } else {
      showToast("Failed to upload avatar.");
    }
  };

  addFriendBtn.onclick = async function () {
    if (user === username) return;
    await fetch("/api/friends/add", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + token
      },
      body: JSON.stringify({ friend: user })
    });
    showToast("Friend added!");
  };
}

function closeProfile() {
  profilePopup.classList.add("panel--hidden");
}

document.getElementById("profileCloseBtn").addEventListener("click", closeProfile);

/* ============================================================
   INITIAL LOAD
============================================================ */
loadDMs();
fetchFriends();
fetchOnlineUsers();
</script>

</body>
</html>
