<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chat Rooms</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/theme.css">
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/chat/style.css">
  <link rel="icon" type="image/x-icon" href="/assets/favicon.ico">
</head>
<body>
<main class="chat-page">
  <section class="chat-shell" id="chatRoot">
    <aside class="chat-rooms" id="chatSidebar">
      <div class="chat-rooms__header">
        <div class="chat-rooms__title">Rooms</div>
        <div class="chat-rooms__header-actions">
          <button type="button" class="chat-rooms__create-btn" id="openCreateRoomBtn">New</button>
          <button type="button" class="chat-rooms__toggle" id="sidebarToggleBtn">Hide</button>
        </div>
      </div>
      <div class="chat-rooms__list" id="channelList"></div>
    </aside>

    <section class="chat-panel">
      <header class="chat-panel__header">
        <div>
          <div class="chat-panel__label" id="currentChannelLabel">#general</div>
          <div class="chat-panel__meta" id="channelMeta">Connected</div>
        </div>
        <div class="chat-panel__actions">
          <button type="button" class="btn btn--small" id="inviteBtn">Invite</button>
          <button type="button" class="btn btn--small" id="reportRoomBtn">Report room</button>
          <button type="button" class="chat-rooms__toggle" id="sidebarToggleBtnHeader">Rooms</button>
          <button id="logoutBtn" class="btn btn--small">Logout</button>
        </div>
      </header>

      <div class="chat-panel__messages" id="chatMessages"></div>
      <div id="typingIndicator" class="chat-panel__typing"></div>

      <footer class="chat-panel__composer">
        <button class="chat-attach-btn" id="attachBtn" title="Attach file">ðŸ“Ž</button>
        <input id="fileInput" type="file" multiple style="display:none;">
        <input id="chatInput" class="input-box chat-input" type="text" placeholder="Message...">
        <button class="chat-send-btn" id="sendBtn">Send</button>
      </footer>
      <div id="attachmentPreview" class="chat-attachment-preview"></div>
    </section>
  </section>
</main>
<div class="chat-modal" id="newRoomModal" aria-hidden="true">
  <div class="chat-modal__panel" role="dialog" aria-modal="true" aria-labelledby="newRoomTitle">
    <div class="chat-modal__header">
      <div class="chat-modal__title" id="newRoomTitle">Create room</div>
      <button type="button" class="chat-modal__close" id="closeCreateRoomBtn" aria-label="Close">âœ•</button>
    </div>
    <div class="chat-modal__body">
      <input id="newRoomInput" class="chat-rooms__input" type="text" placeholder="Create room">
      <div class="chat-modal__actions">
        <button type="button" class="chat-rooms__create-btn" id="createRoomBtn">Add</button>
      </div>
    </div>
  </div>
</div>

<script type="module">
  import { requireAuth } from "/js/auth.js";
  import { mountTopbar } from "/js/layout.js";
  await requireAuth();
  mountTopbar("uchat");
</script>

<script>
const API = {
  rooms: "/api/chat/rooms",
  messages: "/api/chat/messages",
  wsBase: function () {
    const proto = (location.protocol === "https:") ? "wss" : "ws";
    return proto + "://" + location.host + "/chat-ws";
  }
};

let token = localStorage.getItem("token");
let username = localStorage.getItem("username");
let currentChannelId = "";
let currentChannelName = "";
let rooms = [];
let ws = null;
let wsChannelId = "";
let oldestMessageId = null;
let loadingHistory = false;
let attachments = [];
let typingTimeout = null;
let manualClose = false;
let roomRefreshTimer = null;

const chatMessages = document.getElementById("chatMessages");
const chatInput = document.getElementById("chatInput");
const sendBtn = document.getElementById("sendBtn");
const attachBtn = document.getElementById("attachBtn");
const fileInput = document.getElementById("fileInput");
const channelList = document.getElementById("channelList");
const currentChannelLabel = document.getElementById("currentChannelLabel");
const typingIndicator = document.getElementById("typingIndicator");
const sidebarToggleBtn = document.getElementById("sidebarToggleBtn");
const sidebarToggleBtnHeader = document.getElementById("sidebarToggleBtnHeader");
const chatRoot = document.getElementById("chatRoot");
const attachmentPreview = document.getElementById("attachmentPreview");
const channelMeta = document.getElementById("channelMeta");
const inviteBtn = document.getElementById("inviteBtn");
const reportRoomBtn = document.getElementById("reportRoomBtn");
const newRoomInput = document.getElementById("newRoomInput");
const createRoomBtn = document.getElementById("createRoomBtn");
const newRoomModal = document.getElementById("newRoomModal");
const openCreateRoomBtn = document.getElementById("openCreateRoomBtn");
const closeCreateRoomBtn = document.getElementById("closeCreateRoomBtn");

if (!token) {
  window.location.href = "/login.html";
}

function authHeaders() {
  return { Authorization: "Bearer " + token };
}

async function fetchRooms(options) {
  const opts = options || {};
  const shouldSwitch = opts.shouldSwitch !== false;
  const res = await fetch(API.rooms, { headers: authHeaders() });
  if (!res.ok) return;
  const data = await res.json();
  rooms = Array.isArray(data.rooms) ? data.rooms : [];
  renderRoomList();
  if (!rooms.length) {
    currentChannelId = "";
    currentChannelName = "";
    currentChannelLabel.textContent = "#no-room";
    channelMeta.textContent = "No rooms available";
    return;
  }
  if (!rooms.some((room) => room.id === currentChannelId)) {
    currentChannelId = rooms[0].id;
    currentChannelName = rooms[0].name;
  }
  if (shouldSwitch) switchChannel(currentChannelId);
}

function startRoomRefresh() {
  if (roomRefreshTimer) clearInterval(roomRefreshTimer);
  roomRefreshTimer = setInterval(function () {
    fetchRooms({ shouldSwitch: false });
  }, 15000);
}

function renderRoomList() {
  channelList.innerHTML = "";
  if (!rooms.length) {
    const empty = document.createElement("div");
    empty.className = "chat-rooms__empty";
    empty.textContent = "No rooms yet.";
    channelList.appendChild(empty);
    return;
  }
  rooms.forEach(function (room) {
    const row = document.createElement("button");
    row.type = "button";
    row.className = "chat-room" + (room.id === currentChannelId ? " chat-room--active" : "");
    row.textContent = "#" + (room.name || "room");
    row.addEventListener("click", function () {
      switchChannel(room.id);
    });
    channelList.appendChild(row);
  });
}

function switchChannel(roomId) {
  const room = rooms.find((r) => r.id === roomId) || rooms[0];
  if (!room) {
    currentChannelId = "";
    currentChannelName = "";
    currentChannelLabel.textContent = "#no-room";
    channelMeta.textContent = "No rooms available";
    return;
  }
  currentChannelId = room.id;
  currentChannelName = room.name;
  currentChannelLabel.textContent = "#" + (room.name || "room");
  channelMeta.textContent = "Connected";
  if (reportRoomBtn) {
    reportRoomBtn.dataset.room = room.id;
  }
  oldestMessageId = null;
  chatMessages.innerHTML = "";
  connectWS();
  renderRoomList();
  loadHistory(true);
}

function connectWS() {
  if (ws && ws.readyState === WebSocket.OPEN && wsChannelId === currentChannelId) {
    return;
  }
  if (ws) {
    manualClose = true;
    try { ws.close(1000, "switch"); } catch (e) {}
  }
  manualClose = false;
  const url = API.wsBase() + "?token=" + encodeURIComponent(token) +
    "&channel=" + encodeURIComponent(currentChannelId);
  ws = new WebSocket(url);

  ws.onopen = function () {
    wsChannelId = currentChannelId;
    channelMeta.textContent = "Live";
  };

  ws.onmessage = function (event) {
    let data;
    try { data = JSON.parse(event.data); } catch (e) { return; }
    if (data.type === "chat") {
      addMessage(data);
    } else if (data.type === "typing") {
      showTyping(data.user);
    }
  };

  ws.onclose = function () {
    if (manualClose) return;
    channelMeta.textContent = "Disconnected";
  };
}

function showTyping(user) {
  if (user === username) return;
  typingIndicator.textContent = user + " is typing...";
  if (typingTimeout) clearTimeout(typingTimeout);
  typingTimeout = setTimeout(function () {
    typingIndicator.textContent = "";
  }, 1500);
}

async function loadHistory(initial) {
  if (loadingHistory) return;
  loadingHistory = true;
  const url = new URL(API.messages, location.origin);
  url.searchParams.set("channel", currentChannelId);
  url.searchParams.set("limit", "30");
  if (oldestMessageId) url.searchParams.set("beforeId", String(oldestMessageId));

  try {
    const res = await fetch(url.toString(), { headers: authHeaders() });
    if (!res.ok) return;
    const data = await res.json();
    if (initial) chatMessages.innerHTML = "";
    data.messages.forEach(function (msg) {
      prependMessage(msg);
      if (!oldestMessageId || msg.id < oldestMessageId) oldestMessageId = msg.id;
    });
  } finally {
    loadingHistory = false;
  }
}

function createMessageElement(msg) {
  const row = document.createElement("section");
  row.className = "chat-msg-row";
  row.dataset.id = msg.id;

  const header = document.createElement("div");
  header.className = "chat-msg-header";
  const userSpan = document.createElement("span");
  userSpan.className = "chat-msg-user";
  userSpan.textContent = msg.user || "Unknown";
  const timeSpan = document.createElement("span");
  timeSpan.className = "chat-msg-time";
  timeSpan.textContent = new Date(msg.ts || Date.now()).toLocaleTimeString();
  const reportBtn = document.createElement("button");
  reportBtn.type = "button";
  reportBtn.className = "chat-msg-report";
  reportBtn.textContent = "Report";
  reportBtn.addEventListener("click", function () {
    const ref = msg.id || "";
    const url = `/report.html?target_type=chat_message&target_ref=${encodeURIComponent(ref)}`;
    window.location.href = url;
  });
  header.appendChild(userSpan);
  header.appendChild(timeSpan);
  header.appendChild(reportBtn);

  const body = document.createElement("div");
  body.className = "chat-msg-body";
  body.textContent = msg.text || "";

  row.appendChild(header);
  row.appendChild(body);

  if (Array.isArray(msg.attachments) && msg.attachments.length) {
    const list = document.createElement("div");
    list.className = "chat-attachments";
    msg.attachments.forEach(function (att) {
      if (att.isImage) {
        const img = document.createElement("img");
        img.className = "chat-attachment-img";
        img.src = att.url;
        list.appendChild(img);
      } else {
        const link = document.createElement("a");
        link.className = "chat-attachment-link";
        link.href = att.downloadUrl || att.url;
        link.textContent = att.name || "attachment";
        link.target = "_blank";
        list.appendChild(link);
      }
    });
    row.appendChild(list);
  }

  return row;
}

function prependMessage(msg) {
  const row = createMessageElement(msg);
  chatMessages.insertBefore(row, chatMessages.firstChild);
}

function addMessage(msg) {
  const row = createMessageElement(msg);
  chatMessages.appendChild(row);
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

async function sendMessage() {
  const text = chatInput.value.trim();
  if (!text && !attachments.length) return;
  const form = new FormData();
  form.append("channel", currentChannelId);
  form.append("text", text);
  attachments.forEach(function (file) {
    form.append("files", file);
  });
  const res = await fetch(API.messages, {
    method: "POST",
    headers: authHeaders(),
    body: form
  });
  if (res.ok) {
    chatInput.value = "";
    attachments = [];
    attachmentPreview.innerHTML = "";
  }
}

sendBtn.addEventListener("click", sendMessage);
chatInput.addEventListener("keydown", function (e) {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  } else if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "typing" }));
  }
});

attachBtn.addEventListener("click", function () {
  fileInput.click();
});

fileInput.addEventListener("change", function () {
  const files = Array.from(fileInput.files || []);
  attachments = files;
  attachmentPreview.innerHTML = "";
  files.forEach(function (file) {
    const chip = document.createElement("div");
    chip.className = "chat-attachment-preview__item";
    chip.textContent = file.name;
    attachmentPreview.appendChild(chip);
  });
});

chatMessages.addEventListener("scroll", function () {
  if (chatMessages.scrollTop < 80) loadHistory(false);
});

function setSidebarCollapsed(collapsed) {
  chatRoot.classList.toggle("chat-shell--collapsed", collapsed);
  const label = collapsed ? "Show" : "Hide";
  sidebarToggleBtn.textContent = label;
  sidebarToggleBtnHeader.textContent = collapsed ? "Rooms" : "Hide Rooms";
}

sidebarToggleBtn.addEventListener("click", function () {
  setSidebarCollapsed(!chatRoot.classList.contains("chat-shell--collapsed"));
});
sidebarToggleBtnHeader.addEventListener("click", function () {
  setSidebarCollapsed(!chatRoot.classList.contains("chat-shell--collapsed"));
});

async function createRoom() {
  const name = (newRoomInput.value || "").trim();
  if (!name) return;
  createRoomBtn.disabled = true;
  try {
    const res = await fetch(API.rooms, {
      method: "POST",
      headers: { ...authHeaders(), "Content-Type": "application/json" },
      body: JSON.stringify({ name })
    });
    if (!res.ok) return;
    const data = await res.json();
    rooms = Array.isArray(data.rooms) ? data.rooms : rooms;
    newRoomInput.value = "";
    renderRoomList();
    if (data.created && data.created.id) switchChannel(data.created.id);
    newRoomModal.classList.remove("is-open");
  } finally {
    createRoomBtn.disabled = false;
  }
}

createRoomBtn.addEventListener("click", createRoom);
newRoomInput.addEventListener("keydown", function (e) {
  if (e.key === "Enter") {
    e.preventDefault();
    createRoom();
  }
});
openCreateRoomBtn.addEventListener("click", function () {
  newRoomModal.classList.add("is-open");
  newRoomInput.focus();
});
closeCreateRoomBtn.addEventListener("click", function () {
  newRoomModal.classList.remove("is-open");
});
newRoomModal.addEventListener("click", function (e) {
  if (e.target === newRoomModal) {
    newRoomModal.classList.remove("is-open");
  }
});

inviteBtn.addEventListener("click", async function () {
  if (!currentChannelId) return;
  channelMeta.textContent = "Creating invite...";
  try {
    const res = await fetch("/api/chat/invites", {
      method: "POST",
      headers: { ...authHeaders(), "Content-Type": "application/json" },
      body: JSON.stringify({ channel_id: currentChannelId })
    });
    if (!res.ok) {
      channelMeta.textContent = "Invite failed.";
      return;
    }
    const data = await res.json();
    const url = `${location.origin}/chat/index.html?invite=${encodeURIComponent(data.token)}`;
    if (navigator.clipboard?.writeText) {
      await navigator.clipboard.writeText(url);
      channelMeta.textContent = "Invite link copied.";
    } else {
      channelMeta.textContent = "Invite link ready.";
      window.prompt("Copy invite link:", url);
    }
  } catch {
    channelMeta.textContent = "Invite failed.";
  }
});

reportRoomBtn.addEventListener("click", function () {
  if (!currentChannelId) return;
  const ref = reportRoomBtn.dataset.room || currentChannelId;
  const url = `/report.html?target_type=chat_room&target_ref=${encodeURIComponent(ref)}`;
  window.location.href = url;
});

document.getElementById("logoutBtn").addEventListener("click", function () {
  localStorage.removeItem("token");
  localStorage.removeItem("username");
  window.location.href = "/login.html";
});

const inviteToken = new URLSearchParams(location.search).get("invite");
if (inviteToken) {
  fetch(`/api/chat/invites/${encodeURIComponent(inviteToken)}`, { headers: authHeaders() })
    .then((res) => res.ok ? res.json() : null)
    .then((data) => {
      if (data?.channel?.id) {
        currentChannelId = data.channel.id;
        currentChannelName = data.channel.name;
      }
    })
    .finally(() => fetchRooms().finally(startRoomRefresh));
} else {
  fetchRooms().finally(startRoomRefresh);
}
</script>
</body>
</html>
